-- MySQL dump 10.13  Distrib 5.5.46, for debian-linux-gnu (x86_64)
--
-- Host: localhost    Database: awesome
-- ------------------------------------------------------
-- Server version	5.5.46-0ubuntu0.14.04.2

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `blogs`
--

DROP TABLE IF EXISTS `blogs`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blogs` (
  `id` varchar(50) NOT NULL,
  `user_id` varchar(50) NOT NULL,
  `user_name` varchar(50) NOT NULL,
  `user_image` varchar(500) NOT NULL,
  `name` varchar(50) NOT NULL,
  `summary` varchar(200) NOT NULL,
  `content` mediumtext NOT NULL,
  `created_at` double NOT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_created_at` (`created_at`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blogs`
--

LOCK TABLES `blogs` WRITE;
/*!40000 ALTER TABLE `blogs` DISABLE KEYS */;
INSERT INTO `blogs` VALUES ('001471049240551a8369a838f244b689330b534921d3880000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','我的第一篇博客','这是我的第一篇博客','这是我的第一篇博客。\nstudy hard, play hard!',1446084640),('0014710493015851b1f7d6a0d324bc5a72bf5fd5fa72c06000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','（一）Git使用笔记','一、基本用法','基本用法:\n	\n	1、git init 初始化仓库 \n	2、git add filename/git add . 上传文件 或者 文件夹 \n	3、git commit -m \"上传说明\" \n	4、git status 查看仓库当前状态 \n	5、git diff 查看difference \n	6、git reset --hard (HEAD^..)|版本号 :可以实现回退，将当前HEAD指定新的 git reset --hard commit_id \n	7、git reflog 命令历史，以便确定要回退到哪个版本。 \n	8、git log 可以查看提交历史，以便确定要回退到哪个版本。 \n	9、git checkout -- readme.txt :撤销修改 把readme.txt文件在工作区的修改全部撤销，这里有两种情况： \n     \n     一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样 的状态；\n	 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到 添加到暂存区后的状态。 \n	 git reset HEAD readme.txt 把暂存区的修改撤销掉（unstage），重新放回工作区 （git checkout其实是用版本库里的版本替换工作区的版本，\n	 无论工作区是修改还是删除，都可以“一键还原”。） \n\n	 10、 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，\n     但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。',1448598760),('001471049361323a623cbf8d78641f69e760aa6bfda65b1000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','（二）git使用笔记','远程仓库','11、 由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：\n\n第1步：创建SSH Key。\n\n       $ ssh-keygen -t rsa -C \"youremail@example.com\"\n\n第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：\n\n             点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：\n\n12、添加仓库\n\n        登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：\n\n        在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。\n\n \n\n现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：\n\n$ git remote add origin git@github.com:michaelliao/learngit.git\n\n（ 上面的michaelliao替换成你自己的GitHub账户名） 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。\n\n下一步，就可以把本地库的所有内容推送到远程库上：\n\n$ git push -u origin master\n\n（ 我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。）\n\n\n从现在起，只要本地作了提交，就可以通过命令：\n\n\n$ git push origin master\n\n把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！\n\n \n\n13、从远程库克隆\n\ngit clone git@github.com:michaelliao/gitskills.git\n\n要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。',1449817390),('0014710494137592ce8fa5435ec4501927c843fe7d6cb0e000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','（三）git使用笔记','分支管理','1、创建与合并分支\n\n查看分支：git branch\n\n创建分支：git branch <name>\n\n切换分支：git checkout <name>\n\n创建+切换分支：git checkout -b <name>\n\n合并某分支到当前分支：git merge <name>\n\n删除分支：git branch -d <name>\n\n2、冲突解决\n\n        当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。\n\n        用git log --graph命令可以看到分支合并图。\n\n3、分支管理策略\n\n      通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\n\n        准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward：\n\n        $ git merge --no-ff -m \"merge with no-ff\" dev\n\n      合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。\n\n \n\n4、BUG分支\n\n \n\n修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n\n当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。\n\n \n\n5、Feature分支\n\n \n\n软件开发中，总有无穷无尽的新的功能要不断添加进来。\n\n添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。\n\n \n\n6、多人协作\n\n \n\n因此，多人协作的工作模式通常是这样：\n\n      首先，可以试图用git push origin branch-name推送自己的修改；\n\n      如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；\n\n      如果合并有冲突，则解决冲突，并在本地提交；\n\n      没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！\n\n      如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。\n\n这就是多人协作的工作模式，一旦熟悉了，就非常简单。\n\n（要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：git checkout -b dev origin/dev）\n\n\n\n    查看远程库信息，使用git remote -v；\n\n\n\n    本地新建的分支如果不推送到远程，对其他人就是不可见的；\n\n\n\n    从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；\n\n\n\n    在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；\n\n\n\n    建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；\n\n\n\n    从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。',1450516991),('0014710494654303cddcbd91f814c21a8599679d9c4b157000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','（四）git使用笔记','标签管理','1、创建标签\n\n\n\n    命令git tag <name>用于新建一个标签，默认为HEAD，也可以指定一个commit id；\n\n\n\n    git tag -a <tagname> -m \"blablabla...\"可以指定标签信息；\n\n\n\n    git tag -s <tagname> -m \"blablabla...\"可以用PGP签名标签；\n\n\n\n    命令git tag可以查看所有标签。\n\n\n\n\n2、操作标签\n\n\n\n    命令git push origin <tagname>可以推送一个本地标签；\n\n\n\n    命令git push origin --tags可以推送全部未推送过的本地标签；\n\n\n\n    命令git tag -d <tagname>可以删除一个本地标签；\n\n\n\n    命令git push origin :refs/tags/<tagname>可以删除一个远程标签。',1451995391),('001471049547259c6166b7e7fcd447294dbf1bd27acc7ce000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','最长不重复连续子串求解','求解最长不重复连续子串','问题描述：\n\n   从一个字符串中找到一个连续子串，该子串中任何两个字符不能相同，求子串的最大长度并输出一条最长不重复子串。\n\n1、 能想到的最基本算法就是使用hash，遍历每个字符起始的子串，时间复杂度为O(n^2)，n为字符串的长度，辅助的空间为常数hash[256]。\n\n2、该问题可以动态规划求解：\n     定义一个问题：dp[i]表示以下标为i的字符结尾的子串长度，那么可以由子问题的求解得到。新的子串的长度是与第一个重复的字符的下标有关的\n     （1）dp[i] = dp[i-1] + 1 ，如果该下标在上一个最长子串起始位置之前。\n     （2）如果该下标在上一个最长子串起始位置之后，则新的子串是从该下标之后开始的。\n	 \n	int lengthOfLongestSubstring(string s) {\n		int first = 0;\n		int maxlen = 0;\n		int* d = new int[s.size()+2];\n		memset(d,0,sizeof(int)*(s.size()+2));\n		d[0] = 1;\n		if(s.size()==1)\n		   return 1;\n		for(int i=1;i<s.size();i++){\n			for(int j=i-1;j>=first;j--){\n			  int flag = 0;\n			  if(s[i] == s[j]){\n				d[i] = i - j;\n				first = j + 1;\n				flag = 1;\n			  }else if(j == first){\n				d[i] = d[i-1] + 1;\n			  }\n			  if(d[i]>maxlen){\n				maxlen = d[i];\n			  }\n			  if(flag)\n			   break;\n			}\n		}\n		return maxlen;\n	}\n	\n上面动态规划求解时间复杂度还是O(n²)，主要是还是进行“回头”查找了重复元素位置，其实，上面并不是真正的动态规划方法，因为上面的求解过程没有记录有用的结果，所以可以\n通过记录之前出现的下标来改进算法，这样就不用每次都回去查找重复元素位置，这其实才是真正的动态规划方法，只是记录结果是用的Hash，这样的时间复杂度就是O(n)。\n\n	int lengthOfLongestSubstring(string s) { \n		memset(visit, -1, sizeof visit); \n		memset(dp, 0, sizeof dp); \n		maxlen = 0; \n		dp[0] = 1; \n		visit[s[0]] = 0; \n		int laststart = 0; \n		for(int i = 1; i < s.size(); ++i) { \n			if(visit[s[i]] == -1) { \n				dp[i] = dp[i-1] + 1; \n				visit[s[i]] = i; /* 记录字符下标 */ \n			}else { \n				if(laststart <= visit[s[i]]){ \n					dp[i] = i - visit[s[i]]; \n					last_start = visit[s[i]] + 1; \n					visit[s[i]] = i; /* 更新最近重复位置 */ \n				}else { \n					dp[i] = dp[i-1] + 1; \n				} \n			} \n			if(dp[i] > maxlen) { \n			   maxlen = dp[i]; \n			} \n		} \n		return maxlen;\n	}',1466078591),('001471049678932f0c6e13f2deb40b5b980de46012b61af000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','Longest Palindromic Substring (最长回文子串)','Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.','问题描述：\nGiven a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.\n最简单的办法是遍历所有的子串，判断是否回文，然后找出最长的。\n\n另一种方法的核心思想为从第一个开始当做回文子串的中间字母开始\n\n     向两边查找，只要不符合情况就break\n\n这种有两种情况\n\n1.adfda   ad和da相对于f对称\n\n2.asddsa  asd和dsa直接对称        \nstring longestPalindrome(string s) {<br>        int x = 0;<br>        int y = 0;<br>        int max = 0;<br>        for(int i = 0; i<s.size(); i++){<br>            int j;<br>            for(j=0; i-j>=0&&i+j<s.size(); j++){<br>                if(s[i-j]!=s[i+j])<br>                  break;<br>            }<br>            if(max<((j - 1)*2+1)){<br>                x = i - j + 1;<br>                y = i + j - 1;<br>                max = (j - 1)*2 + 1;<br>            }<br>            int flag = 0;<br>            for(j=0; i-j>=0&&i+j+1<s.size();j++){<br>                if(s[i-j]!=s[i+j+1])<br>                 break;<br>                 flag = 1;<br>            }<br>            if(flag==1&&max<((j - 1)*2+2)){<br>                x = i-j+1;<br>                y = i+j;<br>                max = (j-1)*2 + 2;<br>            }<br>        }<br>        <br>        return s.substr(x,y-x+1);<br>        <br>    }',1466172861),('001471049731169664d7a0a6681446ab3a1896aeb52ef79000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','Linux 结束进程','ps -ef\n查看进程\n\n\n可以看到\n\n用户  和进程编号\n\n可以用kill 进程编号结束进程\n\n\n对于结束不掉的进程可以使用：\n\nkill -s 9 进程编号\n\n强制结束','ps -ef\n查看进程\n\n\n可以看到\n\n用户  和进程编号\n\n可以用kill 进程编号结束进程\n\n\n对于结束不掉的进程可以使用：\n\nkill -s 9 进程编号\n\n强制结束',1471049731.16945),('001471049765163e135d7630f774dfe99c6a30612f5f36e000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','解决关闭终端（关闭SSH等）后运行的程序或者服务自动停止','解决方法：使用nohup命令让程序在关闭窗口（切换SSH连接）的时候程序还能继续在后台运行。','解决方法：使用nohup命令让程序在关闭窗口（切换SSH连接）的时候程序还能继续在后台运行。\n\n\nUnix/Linux下一般比如想让某个程序在后台运行，很多都是使用& 在程序结尾来让程序自动运行。比如我们要运行mysql在后台：\n\n/usr/local/mysql/bin/mysqld_safe --user=mysql &\n\n但是加入我们很多程序并不象mysqld一样做成守护进程，可能我们的程序只是普通程序而已，一般这种程序使用& 结尾，但是如果终端关闭，那么程序也会被关闭。但是为了能够后台运行，那么我们就可以使用nohup这个命令，比如我们有个test.php需要在后台运行，并且希望在后台能够定期运行，那么就使用nohup：\n\n       nohup /root/test.php &\n\n　　提示：\n\n　　[~]$ appending output to nohup.out\n\n　　嗯，证明运行成功，同时把程序运行的输出信息放到当前目录的nohup.out 文件中去。\n\n\n      用途：不挂断地运行命令。\n\n \n\n　　语法：nohup Command [ Arg ... ] [　& ]\n\n \n\n　　描述：nohup 命令运行由 Command 参数和任何相关的 Arg 参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 & （ 表示“and”的符号）到命令的尾部。',1471049765.16351),('0014713322282950e2a1191bd9f475da5555136bbfbe241000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','push本地代码到github出错','push本地代码到github出错时的解决方法','root@iZ28tcs0im9Z:/home/zhujh_blog# git push -u origin master\n\nTo git@github.com:luckyDog123/zhujh_blog.git\n\n ! [rejected]        master -> master (non-fast-forward)\n\nerror: failed to push some refs to \'git@github.com:luckyDog123/zhujh_blog.git\'\n\nhint: Updates were rejected because the tip of your current branch is behind\n\nhint: its remote counterpart. Integrate the remote changes (e.g.\n\nhint: \'git pull ...\') before pushing again.\n\nhint: See the \'Note about fast-forwards\' in \'git push --help\' for details.\n\n是因为远程repository和我本地的repository冲突导致的，而我在创建版本库后，在github的版本库页面点击了创建\n\nREADME.md文件的按钮创建了说明文档，但是却没有pull到本地。这样就产生了版本冲突的问题。\n\n有如下几种解决方法：\n\n1.使用强制push的方法：\n\n     $ git push -u origin master -f  这样会使远程修改丢失，一般是不可取的，尤其是多人协作开发的时候。\n\n2.push前先将远程repository修改pull下来\n\n    $ git pull origin master   再将新文件加入，然后\n\n    $ git push -u origin master\n\n3.若不想merge远程和本地修改，可以先创建新的分支：\n\n    $ git branch [name]\n\n    然后push\n\n    $ git push -u origin [name]',1471332228.29556),('00147133447734251fa85575d664eddb4a18b9b3b84e26d000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','aiohttp','asyncio实现了TCP、UDP、SSL等协议，aiohttp则是基于asyncio实现的HTTP框架。','asyncio可以实现单线程并发IO操作。如果仅用在客户端，发挥的威力不大。如果把asyncio用在服务器端，例如Web\n\n服务器，由于HTTP连接就是IO操作，因此可以用单线程+coroutine实现多用户的高并发支持。\n\n编写一个HTTP服务器，分别处理以下URL：\n\n    1、/ - 首页返回b\'<h1>Index</h1>\'；\n\n    2、/hello/{name} - 根据URL参数返回文本hello, %s!。\n\n代码如下：\n\n	import asyncio\n\n	from aiohttp import web\n\n	async def index(request):\n\n		await asyncio.sleep(0.5)\n\n		return web.Response(body=b\'<h1>Index</h1>\')\n\n\n\n	async def hello(request):\n\n		await asyncio.sleep(0.5)\n\n		text = \'<h1>hello, %s!</h1>\' % request.match_info[\'name\']\n		\n		return web.Response(body=text.encode(\'utf-8\'))\n\n	async def init(loop):\n		\n		app = web.Application(loop=loop)\n		\n		app.router.add_route(\'GET\', \'/\', index)\n		\n		app.router.add_route(\'GET\', \'/hello/{name}\', hello)\n		\n		srv = await loop.create_server(app.make_handler(), \'127.0.0.1\', 8000)\n	   \n		print(\'Server started at http://127.0.0.1:8000...\')\n		\n		return srv\n\n\n	loop = asyncio.get_event_loop()\n\n	loop.run_until_complete(init(loop))\n\n	loop.run_forever()\n\n注意aiohttp的初始化函数init()也是一个coroutine，loop.create_server()则利用asyncio创建TCP服务。',1471334477.3425),('001471418014635d09720ad34c54072ac9ee54d8faeab18000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','java反射机制学习','一直不太理解反射机制，最近好好学习了下，反射机制指的是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。','Java反射机制\n\n一直不太理解反射机制，最近好好学习了下，反射机制指的是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。\n\n    反射机制的作用有很多，比如学jdbc时用过一行代码，Class.forName(\"com.mysql.jdbc.Driver.class\").newInstance();，那时只知道那行代码是生成驱动对象实例，并不知道它的具体含义。\n后来才知道，原来这就是反射，现在很多开源框架都用到反射机制，hibernate、struts都是用反射机制实现的。\n   \n静态编译：在编译时确定类型，绑定对象。动态编译：运行时确定类型，绑定对象。\n动态编译最大限度发挥了java的灵活性，体现了多态的应用，有以降低类之间的藕合性。 而反射机制的优点就是可以实现动态创建对象和编译，体现出很大的灵活性。\n比如，一个大型的软件，不可能一次就设计完美，当编译发布了，当发现需要更新某些功能时不可能要用户把以前的卸载重新安装。采用静态的话，需要把整个程序重\n\n1、反射机制获取类的方法：\n	\n	//第一种方式：  \n	Classc1 = Class.forName(\"Employee\");  \n	//第二种方式：  \n	//java中每个类型都有class 属性.  \n	Classc2 = Employee.class;  \n	//第三种方式：  \n	//java语言中任何一个java对象都有getClass 方法  \n	Employeee = new Employee();  \n	Classc3 = e.getClass(); //c3是运行时类 (e的运行时类是Employee)  \n	\n2、创建对象：获取类以后我们来创建它的对象，利用newInstance：\n\n	Class c =Class.forName(\"Employee\");  	  \n	//创建此Class 对象所表示的类的一个新实例  \n	Objecto = c.newInstance(); //调用了Employee的无参数构造方法.  \n\n3、获取属性：分为所有的属性和指定的属性：\n\n            //获取整个类  \n            Class c = Class.forName(\"java.lang.Integer\");  \n              //获取所有的属性?  \n            Field[] fs = c.getDeclaredFields();         \n             //定义可变长的字符串，用来存储属性  \n            StringBuffer sb = new StringBuffer();  \n            //通过追加的方法，将每个属性拼接到此字符串中  \n            //最外边的public定义  \n            sb.append(Modifier.toString(c.getModifiers()) + \" class \" + c.getSimpleName() +\"{\\n\");  \n            //里边的每一个属性  \n            for(Field field:fs){  \n                sb.append(\"\\t\");//空格  \n                sb.append(Modifier.toString(field.getModifiers())+\" \");//获得属性的修饰符，例如public，static等等  \n                sb.append(field.getType().getSimpleName() + \" \");//属性的类型的名字  \n                sb.append(field.getName()+\";\\n\");//属性的名字+回车  \n            }  \n            sb.append(\"}\");  \n            System.out.println(sb);  \n			/* \n			User u = new User(); \n			u.age = 12; //set \n			System.out.println(u.age); //get \n			*/  \n					  \n			//获取类  \n			Class c = Class.forName(\"User\");  \n			//获取id属性  \n			Field idF = c.getDeclaredField(\"id\");  \n			//实例化这个类赋给o  \n			Object o = c.newInstance();  \n			//打破封装  \n			idF.setAccessible(true); //使用反射机制可以打破封装性，导致了java对象的属性不安全。  \n			//给o对象的id属性赋值\"110\"  \n			idF.set(o, \"110\"); //set  \n			//get  \n			System.out.println(idF.get(o));   \n\n4、获取方法，和构造方法，不再详细描述，只来看一下关键字：\n\n			方法关键字  含义\n			getDeclaredMethods()\n			获取所有的方法\n			getReturnType()\n			获得方法的放回类型\n			getParameterTypes()\n			获得方法的传入参数类型\n			getDeclaredMethod(\"方法名\",参数类型.class,……)\n			获得特定的方法\n			\n			构造方法关键字 含义\n			getDeclaredConstructors()\n			获取所有的构造方法\n			getDeclaredConstructor(参数类型.class,……)\n			获取特定的构造方法\n			 \n			父类和父接口  含义\n			getSuperclass()\n			获取某类的父类\n			getInterfaces()\n			获取某类实现的接口\n\n			\n实例：\n    模拟spring的IOC机制，读取配置文件，实现类的动态加载。Spring的一个配置文件格式如下：\n	\n		<beans>\n		  <bean id=\"u\" class=\"com.bjsxt.dao.impl.UserDAOImpl\" >\n		  </bean>\n		  <bean id=\"userService\" class=\"com.bjsxt.service.UserService\" >\n			<property name=\"userDAO\" bean=\"u\"/>\n		  </bean>\n		</beans>\n\n		\n我们可以用Pattern pattern =Pattern.compile (\"<beans>(.+?)</beans>\"); 来获取bean对象配置信息，然后再次利用正则表达式获取每个bean信息。\n在这里 我自定义了一个配置文件信息，放到字符串中。其配置格式为： 属性名称：值\n\n		String Configure=\"Class:com.bjsxt.service.school,Method:getStudentInfo,args:Tom,argsType:java.lang.String\";//格式固定 可以用正则表达式提取\n			String []split={\":\",\",\"};//格式为   name:value, 所以分隔符为 ： ， \n			parseData p=new parseData(Configure);//实现方式为正则表达式提取需要的字符串\n			//(1) 获取类名 方法名 参数 参数类型信息  \n			String className= p.getInfo(\"Class\", split);\n			  String MethodName=p.getInfo(\"Method\", split);\n			  String arg=p.getInfo(\"args\", split);\n			  Object []args={arg};\n		  String argsType=p.getInfo(\"argsType\", split);\n		  \n整体实现代码：\n\n			package com.bjsxt.service;\n\n			import java.lang.reflect.InvocationTargetException;\n			import java.lang.reflect.Method;\n\n			public class DynamicInvocation {\n				 public static void main(String[] a) throws Exception {\n				String Configure=\"Class:com.bjsxt.service.school,Method:getStudentInfo,args:Tom,argsType:java.lang.String\";//格式固定 可以用正则表达式提取\n				String []split={\":\",\",\"};//格式为	name:value, 所以分隔符为 ： ， \n				parseData p=new parseData(Configure);//实现方式为正则表达式提取需要的字符串\n				//(1) 获取类名 方法名 参数 参数类型信息  \n				String className= p.getInfo(\"Class\", split);\n				 String MethodName=p.getInfo(\"Method\", split);\n				 String arg=p.getInfo(\"args\", split);\n				 Object []args={arg};\n				 String argsType=p.getInfo(\"argsType\", split);\n				//(2) 创建未知对象实例\n				Object s=Class.forName(className).newInstance();// 注意我们目前创建的对象并不知道其类型\n				//(3)方法调用\n				//3.1仅通过方法名查找查找方法并调用 缺点：有可能有方法是重载的\n				DynamicInvocation inv=new DynamicInvocation();\n				inv.invokeMethodGernaral(s, MethodName, args);\n				//3.2通过方法名 和参数 查找方法并调用\n				Class cls=Class.forName(argsType);\n				System.out.println(cls.getName());\n				Class []clz={cls};\n				inv.invokeMethod(s, MethodName, clz, args);\n				//（4）动态强制类型转换\n				Class intClass=Class.forName(\"java.lang.Integer\");\n				System.out.println(Integer.class);\n				\n			  }\n			  public Object invokeMethodGernaral(Object owner,String methodName,Object[]args)//只通过方法的名字进行查找 并调用\n				{\n				  //a.先获取对象所属的类\n				  Class ownerClass=owner.getClass();\n				   Method method=null;\n				   Object result=null;\n					//b.获取需要调用的方法\n				   for(Method m:ownerClass.getDeclaredMethods())\n				   {\n					if(m.getName().equalsIgnoreCase(methodName))\n					{\n						method=m;\n						break;\n					}\n				   }\n				   try {\n				   //c.调用该方法\n					result=method.invoke(owner, args);//调用方法\n				  } catch (IllegalAccessException e) {\n					// TODO Auto-generated catch block\n					e.printStackTrace();\n				  } catch (IllegalArgumentException e) {\n					// TODO Auto-generated catch block\n					e.printStackTrace();\n				  } catch (InvocationTargetException e) {\n					// TODO Auto-generated catch block\n					e.printStackTrace();\n				  }\n				   return result;\n				}\n			  public Object invokeMethod(Object owner,String methodName,Class[]clz,Object[] args) throws Exception {  \n				 //a.得到对象所属类	 \n				 Class ownerClass=owner.getClass();\n				 //b.根据方法名称和参数名称 获取该类的某个方法	\n				 Method method=ownerClass.getMethod(methodName,clz);//第二个参数是通过类型来获取 有个缺点就是参数类型必须要填写\n				 //c.执行某个对象的方法  \n				 Object result=method.invoke(owner,args); //必须要有类对象才可以调用\n				 //d.输出结果信息  \n				 System.out.println(\"结果返回值：\"+ result);  \n				 return result;  \n			  }  \n			}\n			package com.bjsxt.service;\n\n			import java.util.regex.Matcher;\n			import java.util.regex.Pattern;\n\n\n			public class parseData {\n			  private String strSource;//数据源\n			  public parseData(String s)\n			  {\n				this.strSource=s;\n			  }\n			  public  String getInfo(String name,String []split)//名称，值，分隔符\n			  {\n				String str=name+split[0]+\"(.+?)\"+split[1];\n				 //System.out.println(str);\n				  Pattern pattern =Pattern.compile(str);//匹配的模式\n				  Matcher matcher=pattern.matcher(this.strSource);\n				String value=\"\";\n				boolean isFind=false;\n				if(matcher.find())\n				  {\n				  value=matcher.group(1);\n				  }else//可能是最后一个字符\n				  {\n					pattern=Pattern.compile(name+split[0]+\"(.+?)\"+\"$\");//$ 表示为限定结尾\n					  matcher=pattern.matcher(this.strSource);\n					if(matcher.find())\n					{\n						value=matcher.group(1);\n					}\n						\n				  }\n				return value;\n			  }\n\n			}\n		  \n以上就是反射机制的简单的使用，显然学过spring的朋友一定明白了，为什么可以通过配置文件就可以让我们获得指定的方法和变量，在我们创建对象的时候都是通过传进string实现的，就好像你需要什么，我们去为你生产，还有我们一直在用Object,这就说明java语言的动态特性，依赖性大大的降低了。',1471418014.63571),('001471424308735c52440a03b8a4b50ad03083c17d357cf000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','Regular Expression Matching','Implement regular expression matching with support for \'.\' and \'*\'.','题目描述：\n\n	Implement regular expression matching with support for \'.\' and \'*\'.\n\n	\'.\' Matches any single character.\n	\'*\' Matches zero or more of the preceding element.\n\n	The matching should cover the entire input string (not partial).\n\n	The function prototype should be:\n	bool isMatch(const char *s, const char *p)\n\n	Some examples:\n	isMatch(\"aa\",\"a\") → false\n	isMatch(\"aa\",\"aa\") → true\n	isMatch(\"aaa\",\"aa\") → false\n	isMatch(\"aa\", \"a*\") → true\n	isMatch(\"aa\", \".*\") → true\n	isMatch(\"ab\", \".*\") → true\n	isMatch(\"aab\", \"c*a*b\") → true\n\n核心思路是一个动态规划，dp[i][j]表示字串 s[i...len(s)], p[j...len(p)] 是否可以匹配。\n状态转移方程如下：\n\n	dp[i][j] = \n			  c1. p[j+1] != \'*\'时   if s[i] == p[j]  dp[i][j] = dp[i+1][j+1] \n									else dp[i][j] = false\n			  c2 p[j+1] == \'*\'时  (这个情况下，要扩展 *, dp[i][j] 从拓展的情况下，选择一个是真的结果）\n									if( s[i] ==  p[j] || p[j] == \'.\' && (*s) != 0)  \n									当s[i] 和 p[j] 一样的时候，例如 aba, a*b这个时候，i = 0, j = 0, 自然可以匹配a a\n									如果p[j] == .  因为他可以匹配任何字符，所以和相等关系有基本一样的方式。\n									并且每一步匹配都要递增 i 的值，如果有成立的，则返回true，否则到匹配终了，返回通配符匹配完成后的结果。\n									\n代码描述：\n\n		bool isMatch(string s, string p) {\n				\n				if(p.size()==0)\n				   return s.size() == 0;\n				int i = 0;\n				int j = 0;\n				\n				if(p[j+1]==\'*\'){\n					while(s[i]==p[j] || i<s.size()&&p[j]==\'.\')\n					   {\n						   if(isMatch(s.substr(i),p.substr(j+2)))\n							  return true;\n						   i++;\n					   }\n					return isMatch(s.substr(i),p.substr(j+2));\n					 \n				}else{\n					if(s[i]==p[j] || i<s.size()&&p[j]==\'.\')\n					  return isMatch(s.substr(1),p.substr(1));\n				}\n				return false;\n		}',1471424308.73539),('001471435479156dbc1f9a813e547e78ac63ff320c06646000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','Container With Most Water','Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two ','题目描述：\n\n    Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that \n	the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container \n	contains the most water.\n	\n解题思路，从两边向中间扫描，计算矩形面积，取最大值\n\n	 int maxArea(vector<int>& height) {\n			\n			int len = height.size();\n			int i = 0;\n			int j = len - 1;\n			int maxArea = 0;\n			while(i<j){\n				int area = 0;\n			   if(height[i]<height[j]){\n				   area = height[i] * (j-i);\n				   i++;\n			   }else{\n				   area = height[j] * (j-i);\n				   j--;\n			   }\n			   if(maxArea<area)\n				  maxArea = area;\n			}\n			return maxArea;\n		}',1471435479.15667),('00147143876800992562f7903b2404198dc5df3a4d6c831000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','9个offer，12家公司，35场面试，从微软到谷歌，应届计算机毕业生的2012求职之路(转)','本文转自http://www.cnblogs.com/figure9/archive/2013/01/09/2853649.html','1，简介\n\n	毕业答辩搞定，总算可以闲一段时间，把这段求职经历写出来，也作为之前三个半月的求职的回顾。 \n\n	首先说说我拿到的offer情况：\n\n	微软，3面->终面，搞定\n\n	百度，3面->终面，口头offer\n\n	搜狗，2面，悲剧\n\n	腾讯，1面，悲剧\n\n	布丁移动，3面，搞定\n\n	涂鸦游戏，3面，搞定\n\n	友盟，3面->CEO面，搞定\n\n	雅虎，4面->终面，搞定\n\n	微策略，2面，悲剧\n\n	人民搜索，3面->终面，搞定\n\n	人人，2面+终面+Special面，搞定\n\n	Google，7面，搞定\n\n	求职经历分为定位、准备、简历、笔试和面试这五个部分，大家挑感兴趣的看就成。\n\n	我的求职经历适用但不限于码农，不适用与企事业单位（据说是完全不同的考察标准和流程）。废话比较多，大家耐心忍受，有什么问题可以跟帖提问。\n\n2，定位\n\n	教育经历：本科在大连某工科院校，由于GPA比较惨烈+挂科，所以没保成研，毕业后修了一年英语双学位，然后到帝都计算机职业教育学院接受再教育。\n\n	技术能力：属于半码农半产品的类型，代码编的过去（搞过compiler），也有一些拿的出手的产品（几十w的用户量），一句话描述：几十w代码+几十w用户的Coder。\n\n	专业能力：非ACM出身，算法拙计但基础扎实。由于单身所以看了N多书（CS+心理+经管+历史），扯淡能力强大，碰到非专业的各种秒杀，碰到专业各种拙计。\n\n	实习经历：大四在一家ds公司实习过一年，攒了不少代码量；后来在MS断断续续的待了一年多，虽说是打酱油，但在众大神的光环笼罩下，水平至少提了三个档。\n\n	目标公司：由于百度给我的印象实在很差，而MS给我的印象又实在很好，所有就有了下面的排名：\n\n	外企（Google、MS、Yahoo等）>国内互联网（阿里、腾讯、百度、网易等）>企事业单位（基本不考虑） \n\n3，准备\n\n	经常在论坛里看到各种求职抱怨贴，其实在抱怨前应该仔细想一想，为了求职，你付出了多少？看到人家找工作找的顺找的爽，有没有想过人家背地里付出了多少努力和心血？别拿官二代和富二代啥的说事，真ds只会拿一堆自身以外的理由掩饰自己的懒惰。\n\n	不要认为求职就是发个简历等面试通知，对于大神来说不用发简历牛逼公司也会围着你转，对于ds来说就是预则立不预则废，中国缺什么就是不缺人，不下功夫准备很有可能连个P都没有。\n\n	其实很多ds就是怕预也废所以干脆不准备直接上，这样搞不定的话，就有借口说不是自己蠢而是自己没准备，可以捍卫自己的智商高地不被侵犯。身边有不少这样的实例，典型的死要面子活受罪，活该你找不到工作。\n\n	我的微软mentor曾提到过，我的实习面试表现一般，但后来表现出的动手能力大大超出之前面试的预估，而有些面试表现很出色，问题对答如流的选手，入职之后反而不是很理想，至少没有达到面试时发挥出的水准。\n\n	这说明一个问题，就是笔试面试，准备和不准备会差异很大。如果你的简历不是那么NB，那就只能靠笔试和面试的加分撑场面。身边经常有同学纳闷这样代码都编不利索的傻屌都能进MS为什么我不能进，答案往往很简单：人家比你多准备了一个月。平时电脑上写程序可能很利索，笔试面试时在纸上写写试试你就知道什么叫拙计。\n\n	IT公司的笔试和面试的题量都不大（相对于企事业单位和银行动辄上百道选择题的题量，算是很少），一般十几道选择题，三四道大题就算题量很大。但计算机的东西实在又是太多，程序设计、数据结构、算法设计、操作系统、体系结构、编译原理、数据库、软件工程等分支，编译的话太难（一千个码农里也没几个人能在纸上写一个最基础的递归下降LLParser），软件工程、体系结构、数据库这些太水（不是说这些分支没用，而是它们很难考察，尤其对应届生来说这些都是些文字游戏，比如说面向对象的三要素五原则，有个鸟用），这么一排除，再把数据结构和算法设计一合并，就剩下程序设计、算法和操作系统。没错，这三项搞定，国内外IT公司通杀。\n\n	因此我的笔试和面试准备很简单，就是重温+突击程序设计、算法和操作系统。下面是我的笔试+面试准备内容： \n\n	程序设计：\n\n	1，把基础的数据结构的C语言实现在纸上写三遍以上，用我能想到的最精简最优化的方法\n\n	2，阅读CARM和TCPL，确保不会遗漏C语言的每个细节\n\n	3，重温之前自己做过的靠谱项目，并总结里面的关键难题和解决思路\n\n	4，重读Writing Solid Code、Elements of Programming、Practice of programming\n\n	5，阅读Science of Programming，做到可以证明自己的程序的正确性（前条件+后条件+不变式） \n\n	算法：\n\n	1，重读Algorithm Design Manual，重点阅读Dynamic Programming和Backtraverse\n\n	2，重读Programming Pearls和More Programming Pearls，并完成所有课后题\n\n	3，独立解决编程之美里面的题目（国内不少企业选题用的这本书）\n\n	4，完成Careercup里Amazon、Google和Microsoft这三个分类下面的前20页面试题\n\n	5，完成TopCoder的数十道D1L2~D2L1难度区间的算法题目 \n\n	操作系统：\n\n	1，重读Modern Operating System，重温OS的核心概念\n\n	2，重读Computer Systems a Programmer\'s Perspective的关键章节，回顾里面的关键点 \n\n	从七月底开始一直到十一月，花了接近四个月，很多东西都是一边面试一边准备：面试->发现盲点->修复盲点。 \n\n	 \n\n	此外列出一些面试笔试题的资源，此外感谢基友@codewarrior之前的推荐：\n\n	1，Crack over the code interview\n\n	很靠谱的笔试面试指导手册\n\n	2，CareerCup\n\n	集齐了大量的真实笔试面试题，去外企的一定得看\n\n	3，TopCoder\n\n	如果不是ACM，练这个就够，其实面试也不会问太难的算法，哪怕是google\n\n	4，编程之美\n\n	尽管题目有些过时，但依然很实用，三星题目适合一个人仔细想 \n\n	此外也说下一些不靠谱的资源：\n\n	1，IT公司面试100题\n\n	这个恐怕是国内传的最多的IT面试题\n\n	题目本身还可以，但那个出题人本身代码功底一般，给出的答案包含大量错误和缺陷，导致参考价值骤降\n\n	2，程序员面试宝典\n\n	翔一样的书，各种错误概念的堆积，如果一个错误给我一块钱，我能从这本书搞成万元户。如果去正规公司拿这本书准备，包你被黑出翔。 \n\n4，简历\n\n	在MS时，老大曾让我帮忙招几个靠谱的实习生，因此我收到了几百封简历，过了一把HR的瘾。这里说说自己在看简历时发现的几点：\n\n	1，可读性。不要用Word或压缩包，用PDF。此外在邮件里面用纯文本加上自己的简介，简化对方阅读的操作。要记住HR一天看的简历海的去了，压缩包是HR最痛恨的格式，因为解压了就不知道扔哪去了，有时干脆就不看；Word有版本问题，10的docx到了07往往被黑出翔。还有就是对方有可能不在PC上读邮件，因此纯文本的简介非常有必要。\n\n	2，群发。不要给人群发的嫌疑，看清楚目标职位和目标公司，我发的工程院招聘贴，收到的几百封简历里面有十余封是投到微软亚洲研究院，有几个干脆写“敬爱的某领导”，尼玛这不找抽么。\n\n	3，设计。特别提一下设计，很多电工的简历就是翔，丑的一逼，对齐没有，字体拙计，要点不明。再放到几百份几千份简历里面，活该你被忽略。建议所有电工投简历前阅读《给大家看的设计书》，至少搞明白里面的C.R.A.P四原则。不要小看设计的威力，在简历内容接近的情况下，良好的设计会大大加分。\n\n	4，篇幅。控制在一页以内。倒不是说不能写两页，而是HR没时间看两页这么多。而且就我看过的几百封简历而言，凡是超过两页的没一个靠谱，有这么高的先验概率，HR才没工夫一个个筛，反正中国有的是人。\n\n	5，重点。一定要有重点，做到让HR通过简历在20秒内确定你靠不靠谱。可以用加黑字体进行视觉引导。\n\n	6，措辞。甭搞“渴望得到这份工作”、“期待在xxx的工作机会”这样的句式，除了显得你低端，其它毛用没有。\n\n	7，别字。千万不要出现错别字，别字简历一般直接干掉。一页的简历都能出问题，一般不会靠谱。\n\n	因为看了很多不靠谱的简历，我对简历重要性的理解要比其他人深刻很多。首先花了一周把原来两页半的纸缩到一页内，然后找UI朋友帮忙调整了版式、缩进和字体，并找UX朋友帮忙进行重点调整以进行视觉引导，然后在PC和手机上进行了简历可读性测试。从而获得了100%的简历通过率。\n\n	此外，优先走内部推荐，这样最有效率，所以结识各个公司的朋友是非常有必要的。\n\n	海投简历既没必要也没效率，有这个时间不如改改简历来的实在。 \n\n	相关书目：\n\n		1，给大家看的设计书，让你的简历看起来不像一坨翔。\n\n		2，Google Resume，如何写出靠谱的简历，进行靠谱的求职。 \n\n5，笔试\n\n	如之前所说，IT公司的笔试相对单纯（程序设计、算法和操作系统），而且范围较窄，有不少题目被出了一遍又一遍。因此市面上存在大量面试/笔试宝典之类的书籍和题集。\n\n	准备国内的小公司，这些面试/笔试题集还靠的住，因为小公司往往不会在招人环节上下太大的成本，因此他们的试卷一般就是东拼西凑的网上题目；对于大型公司来说，这些题库或是宝典就显的不够用了，尤其是外企。\n\n	所以不要把希望放在运气或是临阵磨枪上。就我自己而言，笔试准备了一个多月，尽管这个时间并不算多，但由于自己平时一直在阅读CS的基础书籍，并做了大量的纸上代码练习，因此笔试通过率也达到了100%（实际上是由于我笔试的公司题目都略简单，据说EMC和网易游戏的笔试难度很高，但当时由于时间冲突没有去成，因此搞出了这个数据）。\n\n	多说无益，这里拿搜狗、腾讯、微软和雅虎这四家公司的笔试试卷为例，简单的介绍下IT公司的笔试题型和题目组成。 \n\n	搜狗：\n\n	题型由十余道不定项选择题和三道算法题目组成，要求在两个小时完成。选择题难度一般，比较杂，也有一些原题；三道算法题目有点意思，至少网上是很难找到，需要一定的算法设计能力（主要是动态规划）才能给出解决。\n\n	搜狗的笔试试题按职位分的很细，从C++开发工程师到iOS开发工程师再到数据挖掘研究工程师十余个职位，每个职位的题目都有一套独立的试卷。但是研发的算法题是一样的，最后一道算法题很有意思，我花了一个多小时才想到利用组合数学里面的知识（多元一次方程非负解）给出设计方案，后来和面试官聊这道题时他们也挺吃惊，因为我的方案比他们的答案还要优化。 \n\n	腾讯：\n\n	题型由二十道单项选择题、六道填空题和两道算法题组成，其中两道算法题是二选一。难度比较简单，题型很广，既有程序设计语言的细节也有概率统计的基本知识，甚至还有C语言的创始人是谁这样的搞笑问题，从选择题上能看得出腾讯在笔试题上还是下了点功夫的，但算法题就太简单了点，至少我认为考不出什么区分度。\n\n	腾讯的笔试试题也是按职位划分的，但就没有搜狗那么细了，研发类笔试题目是统一的，要求一个半小时完成，印象里自己四十分钟就搞定收工，很多人都提前交了试卷，因为确实很简单。 \n\n	微软：\n\n	题型只有二十道不定项选择题，难度较难，要求在一小时四十分钟完成。难度较难，覆盖面非常广，从设计模式，算法分析，代码阅读到C++语言特性，甚至连冷门的函数式程序设计语言都有涉及。\n\n	微软的笔试题目BT之处在于其独特的积分机制：答对了加分，不答无分，答错了倒扣。这就使得很多ds答完试卷感觉自我良好但实际已经被倒扣出翔。以最后一道题为例，答对了加7分，答错倒扣13分，相当于一下子损失20分。所以微软的笔试题会做就得做对，不会做就别蒙，要不更惨。\n\n	此外，微软的笔试题是英文的，加上时间比较短，有些人题都读不完，有些ds连functional language是什么都不知道，自然败的很惨。 \n\n	雅虎：\n\n	题型由十余道单项选择题，一道设计题目和六道算法题目组成，其中六道算法题目是六选二，要求在两个小时完成。难度尚可，主要考察编程能力和算法设计能力。由于时间充裕，尽管是六选二，为了炫技，我直接答了里面的五道题目。然而面试时发现面试官判卷子时并没有把多答的题目考虑在内，囧tz。\n\n	相对于微软，雅虎的题目覆盖面就窄了许多，没有一道题目跳出程序设计、算法和操作系统这个圈的，只要勤加准备，很容易通过。\n\n	雅虎的笔试题也是英文，因此英语作答较为合适，此外，由于算法题目简单，给出optimal solution是必须的，比如说在logN的时间内算fibonacci number是必备的知识，能写binary search就不要写sequential search等等。 \n\n	从笔试题可以明显看出，国外的大型IT公司（比如雅虎，微软和谷歌等）并不在意你现在的skill set，而更看重你的potential，因此题目大多很基础，并具备相当的深度，以确保你对CS有深刻的理解并能够走的很远；而国内的IT公司（比如百度、搜狗和人人等）更看重你现在的skill set，因此会出现不少语言特性，OS操作之类的具体题目，以确保你能够以尽快的速度上手干活，至于能发展到啥程度他们就不care了。\n\n	因此，准备笔试题的时候要确定自己的目标公司：主攻国内公司的话，C++的语言特性、linux基本命令操作这些细节也得准备，因为会有大量此类题目；主攻国外公司的话，良好的英文阅读能力必不可少，此外优秀的代码理解和代码编写能力也不可或缺。\n\n	此外，不要在笔试题目里犯低级错误，不要抄袭（面试时经常会问到笔试题），保持书写的工整（尤其是代码题目和问答题目）。 \n\n	考虑到几乎所有的公司都有编程题目，也就是在纸上写代码，这里推荐几本相关书籍：\n\n	1，Elements of programming style 2nd，写出良好风格的代码。纸上代码一般不长，但短短几行代码往往可以看出这个人的水准，风格很差的代码往往会被pass掉。\n\n	2，Algorithm design manual 2nd，作为非ACM出身的码农，这本书比算导实用很多，课后题也很实在，对回溯，动态规划这些编程技巧讲的非常清楚。\n\n	3，C interfaces and implementation，无论是面试还是笔试，一般都会用C写程序，这本书包含大量的工业级C代码，绝佳的参考和模仿素材。 \n\n	最后推荐下Elements of programming和Structure and interpretation of computer programs，这两本书难度很搞，需要大量的时间阅读，不适合临场阅读准备，但读过后，写出的代码绝逼会上两个层次，这里我就不多介绍了。 \n\n6，面试\n\n	之前有人PM我关于海投简历的问题。我个人不建议海投简历。因为对能力弱的人来说，海投简历只会让他信心更差，没有任何效果，有投简历的时间还不如精心准备少数几个好公司；而对能力强的人来说，海投简历之后会有大量的笔试和面试，笔试很耗体力，面试更很耗体力，不但需要打车或坐地铁在各个公司间穿梭，而且需要在面试时保持精神的高度集中，一般面下来都会精疲力尽，导致接下来的发挥不好。所以还是之前所说，优先内部推荐，然后再根据自己的情况和职业发展路线选择公司，选择职位，不用选太多，集中精力攻破领域内的TOP3即可。就我自己而言，求职期间，我一共投了12封简历，参加了12家公司的面试，一共面了35轮。说多不多，说少不少，因为自己投简历时也是本着互联网公司为主，小公司和企事业单位压根没有投，精准投放的好处在于可以集中精力准备同一类型的公司，从而达到不错的效果。\n\n	关于简历海投的问题就说到这里，接下来讲讲IT公司的面试。需要注意的是我这里聊的都是应届生面试，社会招聘面试可能会有所区别，但整体流程不会有太大差异。\n\n	尽管笔试题会有所差别，但IT公司面试的流程大同小异：标准的技术面试一般有45分钟到60分钟，大约分为三个阶段：\n\n	1，自我介绍（5~10分钟）：\n\n	这个环节的主要目的在于建立面试官和求职者之间的沟通，面试官已经扫过你的简历，但需要对你有进一步的了解，以便建立一个初步印象，并便于进行接下来的技术提问，所以这个环节最常见的问题无外乎“进行一下自我介绍”，有时会加上3分钟或是5分钟的时限，有时会询问“说说你最得意的项目/作品”之类的变体问题。\n\n	由于这个环节相对固定，因此准备起来相对容易，但即便如此，面试初期时我在自我介绍环节也犯过不少错误。这里以我的经历简单的总结下这个环节的要点：\n\n	1，言简意赅，突出亮点\n\n	面试初期时，我犯的一个很大的问题就是自我介绍废话太多，诸如“出生自xx省xx市”，“自我评价xxx”之类的屁话连篇。要知道技术面试不是相亲，这里的自我介绍不是相亲里面的查户口本，而是要了解你这个人靠不靠谱，牛逼不牛逼。如何在3分钟内让别人觉得你牛逼呢？很简单，说且仅说你最牛逼的事迹，让对方留下深刻印象。就技术面试而言，牛逼的事迹包含三方面：做过的项目，读过的书，认识的人。\n\n	如果实在想不出来有啥牛逼事迹，那就比较难办。说实话，换做你是面试官，招一个履历毫无亮点的人进来有何用？ \n\n	2，紧贴简历\n\n	面试官了解你的另外一个途径就是简历，然而短短一两页的简历很难说明白你简历项目中的亮点和难点。就算你不提及，面试官也会在简历中挑他感兴趣的点进行提问，因此自我介绍的内容应该是简历的补充。这样既能留给面试官不错的印象，也能有效节省时间，留出更多的时间进行技术提问环节和问答环节。\n\n	此外，千万不要搞出自相矛盾，比如说简历讲的做了A你在自我介绍中又说是B，这就不是拙计的问题了。 \n\n	3，了解公司需求\n\n	不要试图用一套自我介绍来搞定所有公司，除非你的简历只有一句话（\"Exhausted graphic programming\"或是\"I wrote python\"等）。不同的公司有不同的需求，在Google面前大谈.net技术显然不是什么好的选择（我在google一面中就做过这种挫事）。面试之前要进行详细的调研，了解公司和职位的需求，然后根据他们的需求定制自己的自我介绍和简历，效果会更好。 \n\n	2，技术提问（35~45分钟）：\n\n	通过自我介绍环节，面试官会对你有一个大概的评估，接下来会通过一系列深入的问题考察你的项目经历和技术能力。所以自我介绍环节不要吹牛逼，技术面试是很实在的东西，你有几斤几两问几下就出来，根本忽悠不过去。\n\n	按照MS的分类，技术面试问题分为三类：\n\n	1，Behavior questions：此类问题针对面试者的过往经历，一方面考察面试者的表达能力和实际经验，一方面也可以排除掉一堆在简历上吹牛逼的真ds：\n\n	“说说你最牛逼的项目？”\n\n	2，Hypothetical questions：此类问题会假设出一些场景，让面试者进行作答，主要考察面试者的应变能力和实际经验：\n\n	“给你三天，你会如何把xx项目做得很牛逼？”\n\n	3，Probing questions：如果前两类问题答的不错，面试官往往会追加一些问题，以探测面试者能够走多远，此类问题的出现也是一个标志，面试官对你之前的表现感觉还不错：\n\n	“你会如何改进你做过的最牛逼的项目？”\n\n	就具体技术问题而言，考察题目视你的应聘职位和你的过往经历而定，开发岗会侧重代码编写和系统设计，测试岗会更注重测试用例的编写等细节，产品岗要对线框图，交互设计有了解。不过算法设计和代码编写这两块是肯定有的，毕竟这是程序员的看家功夫，这个搞不定就没有然后了。\n\n	算法设计这块我就不多说了，不搞ACM的码农没啥发言权。代码编写的话这里多说两句：和平时的开发不同，面试时的代码往往是在纸上搞的，而非IDE。很多代码写的还不错的选手往往会在纸上代码这个环节被虐的翔尿齐飞，限于篇幅原因我就不多介绍纸上代码的技巧了，还是那句话，多练习。我自己把Software Tools、Elements of programming和C interface and implementation中的代码在纸上写过几遍，又把常见的面试题目练习了三遍，因此纸上代码环节从来没出过问题。\n\n	3，问答环节（5~10分钟）：\n\n	如果前两个环节进展顺利，就会进入最后的问答环节。这个环节面试官一般会让面试者提几个感兴趣的问题，以增进相互的了解。\n\n	相对于前两个环节，这个环节会轻松很多。不过依然要注意，关于面试表现的问题最好别问，因为问也问不出来什么，至于待遇，那是HR的事情，技术面试官也无能为力。\n\n	最后根据自己的面试经历说说几个细节的问题\n\n	态度：记住你是去求职，证明自己的能力达到职位需求是你的首要任务。没有必要和面试官抬杠，把面试官搞不爽对你一点好处都没有。我在面试搜狗时就出过这问题（直接表示对面试官的问题的不屑），直接一面被砍掉。\n\n	着装：尽管IT公司大多不需要西装革履，但也别太拖沓，穿整齐些，至少给人很精神的感觉。我面试腾讯时直接搞了一件套头衫+迷彩裤+机车帽，结果是面试官从头到尾就没正眼看过我，直接一面被砍掉。\n\n	交流：面试是一个交流的过程，不明白的一定要主动询问，面试的大忌就是面试官给了一个问题，你一声不吭的搞了一个小时，最后发现搞的不是面试官问的问题，这时就算你很牛逼，面试结果往往也是悲剧。\n\n7，国企\n\n	国内的IT公司一共去了6家，拿到6个offer，面试19场。\n\n	百度（2轮面试+1轮终面）\n\n	百度的应届生面试分为3轮，2轮技术面和1轮终面，3轮面试连在一起进行，如果搞到第1轮或第2轮就叫你回去，基本上不是悲剧就是备胎。如果进了终面，只要不出岔子，一般问题不大，因为百度每年招的人非常多，印象里有1500人之多。\n\n	可能是招的人特别多从而导致面试官人数不够，百度的面试在所有大公司里面几乎是最随意的，面试官往往都没有经过系统的面试培训，出的题目也只是从网上东拼西凑，比如像C++的虚函数的实现机制此类SB题目层出不穷。而且有些面试官缺乏对面试者最基本的尊重，我有几个同学在百度面试时差点被面哭。\n\n	就我个人而言，我先后参加了百度的实习生面试和正式员工面试。正式员工面试给我感觉相当不错，流程很规范，面试官很nice，问的问题也说的过去；然而实习生面试那两个人就是翔，不但问的问题很二，而且不给我任何交流的空间，同时在面试过程中表现出一副非常不屑的神情，令人极度不爽。\n\n	此外，百度的员工（包括面试官）给我一种工作过度的感觉，说惊悚些就是印堂发黑。结合艳红哥提到的狼性精神，我这号酱油男说啥也不敢去。\n\n	搜狗（2轮面试）\n\n	搜狗的应届生面试分为4轮，2轮技术+1轮HR+一轮Manager，4轮面试是分开的，所以会比较麻烦，毕竟来回跑来跑去的很费时费力。\n\n	我的搜狗面试经历比较诙谐，尽管面了2轮，但2轮都是一面，第一个一面是朋友帮忙推荐过去的面试，第二个一面是参加搜狗笔试获得的面试机会，从这里多少能看出搜狗招人是有点混乱的。\n\n	第一个一面非常囧，当时面试官问我C++，我表示很少用，接下来问了若干智力题，由于被问的有些拙计，于是反问“这种智力题有什么考察度，会做的人一下子做出来，不会做的一天也搞不定”。估计这句话把面试官搞毛了，接下来的气氛变的很紧张，后来面试官反问我“那你觉得应该怎么招人”，我回答“你们应该学学微软”。然后就没有然后了，囧tz。\n\n	第二个一面感觉还成，因为我笔试的题目答得比较出彩。接下来是一个strcpy的纸上代码和一个简单的OS生产者消费者问题，答得还算顺利，可惜依然没有然后，我怀疑可能是没有Hire Count了。\n\n	搜狗面试给我一个很大的教训，就是别装逼，求职就是求职，别和面试官抬杠。在接下来的面试中，我收敛了很多。\n\n	创新工场（2轮面试+4轮终面）\n\n	创新工场本身是一个孵化公司，它的招聘流程是这样的：工场进行笔试和面试初选，然后由工场下面的子公司进行复选，由于子公司众多，因此工场有一个双选会，每个通过初选的求职者可以选择3家工场的子公司，在这个双选会上开复哥很是鼓吹创业，不过效果似乎不太理想 :-D\n\n	工场的初选面试有两轮，然后是3个子公司的复选面试。和其它公司不一样，工场的面试时间非常短，只有25分钟：一个自我介绍，两个无需写代码的题目。有点拼人品，因为这么短的时间很难考察全面。复选面试大多是电面，比较简单，算法题目说下思路就可以。顺便推荐下友盟，感觉这些子公司里面这家的发展潜力最大。\n\n	腾讯（1轮面试）\n\n	腾讯的应届生面试的组成我不太清楚，因为1轮就GG了。\n\n	腾讯的面试也让人很火大，面试官直接拿一个laptop在那里给你放ppt，一个slide一个题目，答完下一个slide，结果是我说的口干舌燥面试官还没说两句话。题目五花八门，从简历到智力题再到为人处事，印象里答了不下七八道题目，累的一逼还没通过，尼玛。\n\n	不过腾讯的面试中见到很多PLMM，目测有很多非技术岗。\n\n	人人（2轮面试+2轮终面）\n\n	人人的应届生面试一般是2轮面试+1轮终面，由于我的笔试和面试发挥不错，因此又得到了一个加面的机会，拿到了人人special offer，待遇非常给力。\n\n	人人的一面面试官非常nice，我当时迟到了30分钟，由于没吃饭因此直接蹭了几个面包，一边吃一边回答问题一边写代码。由于一面主要考察纸上代码，这个是我的强项，因此很轻松的通过了。二面相对杂一些，数据结构，算法，设计模式，多线程等都有涉及，不过问的都不深，也比较容易。\n\n	终面第一面由自我介绍+读过的书+写一段代码组成，正好刚刚读过Sicence of programming，于是就海侃了一顿程序正确性证明的东西，并用这个证明了下自己的代码的正确性，目测效果还不错。\n\n	终面第二面是一个大manager面试，这一轮主要是自己的职业发展路线等其它非技术问题，聊的也比较顺利，然后他直接告诉我我拿到了special offer。\n\n	人民搜索（2轮面试+1轮终面）\n\n	人民搜索的应届生面试由1轮算法面+1轮设计面+1轮终面组成，每一轮面试都是45分钟，时间控制很严。\n\n	和其它公司的面试不同，人搜的算法面试没有自我介绍环节，直接就是搞算法题目，至少要做两道（难度一般，肯定会有一道动态规划），并在纸上写出完整的代码。由于缺乏沟通，这轮面试略感生硬，不过还是比较顺利的通过了。\n\n	设计面试多了一些沟通环节，接下来大部分时间会讨论一个系统的设计，你需要给出这个系统的架构，接下来面试官会不断的追问如何改进该系统以应对大用户量大数据量等极端情况。我这方面的知识不多，只会很土鳖的hash+cache，磕磕绊绊的把这轮过去了。\n\n	终面面试官是一个前google工程师，正巧当时我在google面了好几轮，比较了解google面试的套路，因此很顺利的就通过了。\n\n	总之，人民搜索的待遇比较给力，而且能搞定户口，如果想在北京长待而且视户口很重，那么人搜值得一试。 \n\n8，外企\n\n	国外的IT公司一共去了4家，拿到3个offer，面试16场。\n\n	微软（2轮面试+1轮终面）\n\n	微软从去年开始大规模扩招，印象里以前应届生招几十人，现在一个STC（互联网工程院）就能招二百余人，因此面试难度也有所下降，面试轮数由以前的5轮左右下降到现在的3轮左右。\n\n	这里多提一句，很多人把微软和MSRA（微软亚洲研究院）划等号，甚至有人认为进了微软就等于进了MSRA，其实微软有很多部门，包括STC、STB、MOD等部门，MSRA只是其中一个研究性质很浓的部门。不过MSRA要求极高，和其它部门不同，一般MSRA的FTE只招博士，很少招硕士，招聘需要进行七轮甚至以上的严格面试，难度丝毫不亚于谷歌。而MSRA的实习生则容易很多，名校学生一般有内部推荐就可以搞定。\n\n	我之前在微软进行过实习，因此直接参加了实习生转正面试，三轮面试分别由SDET，SDE和一名高级部门经理进行面试，面试的流程可以参考我之前提到的常规面试流程。与国内IT公司不同，微软不会问语言细节或是OS细节之类的人品问题（就是那种上网搜一下就明白的题目，C++的虚函数实现机制是此类非常典型的人品题），而会集中在算法设计和程序设计上，其中应届生面试又以纸上代码最为严格，即使到了终面依然会有纸上代码编写环节，尽管不会考察特别复杂的算法，但对细节要求的非常严格。好在我之前有微软几位SDE的指导，纸上代码功夫还是不错的，并且实习期间获得了不错的review，因此比较顺利的通过了微软实习转正面试。\n\n	微策略（2轮面试）\n\n	微策略是一家进入中国没多久的外企，规模不大，工作内容主要是大数据分析+数据可视化，面试一般由四轮到六轮面试组成。我比较悲催的直接挂在第二轮面试。\n\n	微策略是我面试的外企中唯一全程使用英语面试的公司，面试官给人的感觉是很smart，但不nice，具体原因我后面说。\n\n	第一轮面试主要问了些面向对象相关的内容，接下来是一些智力题目，我有一道题目（高楼扔鸡蛋）没有说清楚，尽管答案是正确的，但我的推导思路比较繁琐，因此浪费了大量的时间和面试官进行沟通。事后回想下面试官还是很nice的，主要还是自己平时想问题浅尝辄止，才会败在这道题上。\n\n	第二轮面试就让我感到不爽了，我在自我介绍时直接被面试官打断，以至于自己的亮点经历说都说不出来，而且在后续的编程环节中，面试官拒绝和我进行交流，我写完了题目他又说这个和他要求的不太一样，当时我心里就开始暗骂wtf了。估计是前一轮被评为weak hire以至于这一轮的面试就是走走形式吧。\n\n	雅虎（3轮面试+1轮终面）\n\n	雅虎的面试分为3轮技术面和1轮终面，在同一天完成。尽管雅虎公司一直给我一种摇摇欲坠的感觉（经常有传言雅虎可能会被收购），但雅虎公司的员工给我感觉都很nice且很smart，而且比微软的员工要有活力许多。\n\n	三轮技术面试有两轮是典型的技术面，自我介绍+技术提问，由于我在简历上提到“阅读了120本以上的计算机经典书籍”，因此被问到了“看过最经典的计算机书”这样的问题，我拿Brian Kernighan和Rob Pike的The practice of programming吹了一阵，算法题目相对微软要难一些，除了动态规划，也涉及到了后缀数组等不太常见的数据结构，还好之前有所准备，所以回答的还不错。\n\n	终面的面试官是一名移动部门的老大，问了一些数据结构设计和职业规划的问题，并用英文进行了一小段交流，由于这些问题准备的很充分，因此跟他聊的比较high，终面也很顺利的通过了。\n\n	Google（7轮面试）\n\n	Google的面试轮数不定，如果表现良好，4轮面试就可以拿到offer，但如果有某轮面试表现一般，可能会进行加面来进行确认面试者是否合格，拿我自己来说，进行了7轮面试（据说有进行到10轮以上的，不过无法确认可信性）。Google是典型的工程师文化工程师面试，没有终面这个说法，每个面试官都有一票否决权，加上每个面试官考察的点都不一样，因此Google面试是我经历过的难度最高的面试。\n\n	其实Google的面试我本来没抱多大希望，因为Google一直给我可望不可及的感觉，因此面试时也很放松，这种“自暴自弃”的心态反而让我发挥的不错，一步一步走到最后，并拿到offer。\n\n	Google的面试每一轮大约45分钟，时间卡的比较严格。面试题目肯定会包含算法和程序设计（一般体现为纸上代码），同时包含其它各种各样的问题，我经历了策略题（设计一种策略从而在某个游戏中达到优胜）、数据结构设计、系统设计、白盒/黑盒测试、项目介绍等五花八门的题目，题目的类型视面试官的类型而定：学术型的面试官（比如说名校PHD）问的题目偏重算法，工程型的面试官（大多是社招的Googler）问的题目偏重项目经历。面试题目并不像网上传说的那么困难，但是面试官会抛出很多Probing question，让你给出一个optimal solution，这着实让我拙计了几次，不过即便一时间想不到最优解也不要紧，一边保持和面试官的交流一边试探各种可能的思路，这里再次推荐下Polya的How to solve it。\n\n	由于面试轮数很多，因此这里就不依次说每轮面试的细节，可以参考下面的Google面试经历链接。\n\n	http://blog.yxwang.me/2012/12/job-hunting-in-usa-1/\n\n	http://www.cnblogs.com/cathsfz/archive/2012/08/08/google-interview-experience.html\n\n9，总结\n\n	笔试难度：微策略>人搜>人人>雅虎>搜狗>创新工场>腾讯\n\n	面试难度：Google>雅虎>人搜>微策略>微软>人人>百度>腾讯=搜狗=创新工场\n\n	待遇：Google>人人>人搜>雅虎>微软>百度>创新工场旗下子公司\n\n	毫不犹豫的选择了Google，尽管我自己是.Net流，天天折腾VS和C#，linux和unix啥的都没碰过，但就前景来看，不得不承认Google比微软强太多了。\n\n	老实说我自己进Google感觉像做梦，毕竟不是搞ACM的，大学成绩一般，什么奖学金都没拿过。\n\n	但回想一下，这也不全是靠运气：从07年（那时我大三，一行代码没写过）挂科开始，决心开始搞计算机这行，编写自己的第一行靠谱代码，独立完成第一个编程作业，阅读书籍，不懂的就来D版询问各路大神（这里谢过FloridDong，UGLee等大神），然后一边实习一边读书学习，花了半年考研考到帝都，在考研结束的那段时间（四个月假期）精读了数据结构，计算机组成等基础经典书籍，补习自己的基础。到帝都之后，在一场即兴技术口译之后，获得去微软实习的机会，然后在实习中学习编译器知识，创作了自己的编程语言和编译器，加入朋友的创业团队并合作完成了AppStore TOP1的应用，离开团队独立搞定Windows Phone 7上最火的拨号应用、阅读应用和AV应用并在移动互联网中赚到自己的第一桶金，通宵一周完成毕业小论文发表并推荐到核心期刊，为了求职写了三本纸上代码，阅读the Science of programming学会如何证明自己代码的正确性，100%的简历通过率+100%的笔试通过率，最后进入Google。\n\n	现在回想，感慨万千。',1471438768.00898),('001471483211352d3ad91853746483b8def5a34346ccd24000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','什么是 Event Loop？','Event Loop 是一个很重要的概念，指的是计算机系统的一种运行机制。\nJavaScript语言就采用这种机制，来解决单线程运行带来的一些问题。','Event Loop 是一个很重要的概念，指的是计算机系统的一种运行机制。\nJavaScript语言就采用这种机制，来解决单线程运行带来的一些问题。\nEvent Loop\n本文参考C. Aaron Cois的《Understanding The Node.js Event Loop》，解释什么是Event Loop，以及它与JavaScript语言的单线程模型有何关系。\n想要理解Event Loop，就要从程序的运行模式讲起。运行以后的程序叫做\"进程\"（process），一般情况下，一个进程一次只能执行一个任务。\n如果有很多任务需要执行，不外乎三种解决方法。\n（1）排队。因为一个进程一次只能执行一个任务，只好等前面的任务执行完了，再执行后面的任务。\n（2）新建进程。使用fork命令，为每个任务新建一个进程。\n（3）新建线程。因为进程太耗费资源，所以如今的程序往往允许一个进程包含多个线程，由线程去完成任务。（进程和线程的详细解释，请看这里。）\n以JavaScript语言为例，它是一种单线程语言，所有任务都在一个线程上完成，即采用上面的第一种方法。一旦遇到大量任务或者遇到一个耗时的任务，网页就会出现\"假死\"，因为JavaScript停不下来，也就无法响应用户的行为。\n你也许会问，JavaScript为什么是单线程，难道不能实现为多线程吗？\n这跟历史有关系。JavaScript从诞生起就是单线程。原因大概是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。后来就约定俗成，JavaScript为一种单线程语言。（Worker API可以实现多线程，但是JavaScript本身始终是单线程的。）\n如果某个任务很耗时，比如涉及很多I/O（输入/输出）操作，那么线程的运行大概是下面的样子。\nsynchronous mode\n上图的绿色部分是程序的运行时间，红色部分是等待时间。可以看到，由于I/O操作很慢，所以这个线程的大部分运行时间都在空等I/O操作的返回结果。这种运行方式称为\"同步模式\"（synchronous I/O）或\"堵塞模式\"（blocking I/O）。\n如果采用多线程，同时运行多个任务，那很可能就是下面这样。\nsynchronous mode\n上图表明，多线程不仅占用多倍的系统资源，也闲置多倍的资源，这显然不合理。\nEvent Loop就是为了解决这个问题而提出的。Wikipedia这样定义：\n\"Event Loop是一个程序结构，用于等待和发送消息和事件。（a programming construct that waits for and dispatches events or messages in a program.）\"\n简单说，就是在程序中设置两个线程：一个负责程序本身的运行，称为\"主线程\"；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为\"Event Loop线程\"（可以译为\"消息线程\"）。\nasynchronous mode\n上图主线程的绿色部分，还是表示运行时间，而橙色部分表示空闲时间。每当遇到I/O的时候，主线程就让Event Loop线程去通知相应的I/O程序，然后接着往后运行，所以不存在红色的等待时间。等到I/O程序完成操作，Event Loop线程再把结果返回主线程。主线程就调用事先设定的回调函数，完成整个任务。\n可以看到，由于多出了橙色的空闲时间，所以主线程得以运行更多的任务，这就提高了效率。这种运行方式称为\"异步模式\"（asynchronous I/O）或\"非堵塞模式\"（non-blocking mode）。\n这正是JavaScript语言的运行方式。单线程模型虽然对JavaScript构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果部署得好，JavaScript程序是不会出现堵塞的，这就是为什么node.js平台可以用很少的资源，应付大流量访问的原因。',1471483211.35285),('001471485234819cea6a138282e46eca8804959689a8d59000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','浅谈重构','作者：黄色潜水艇\n链接：http://www.zhihu.com/question/29596513/answer/46252024\n来源：知乎\n著作权归作者所有，转载请联系作者获得授权。','区区五六百行的程序，再大到上W行的代码，都可以让你满怀信心的解决。这个法门就叫做--重构。\n不用担心，它是有方法论的。只要你按下面的步骤，小步修改，确保每次修改后通过测试。我保证：\n变量众多，再牵涉到相互之间的逻辑\n\n	1.你会对这500多行代码的整体结构一目了然，豁然开朗；\n	生怕某个地方改错，导致不可知的错误\n	2.对每一次修改都充满信心，对它的影响范围都了如指掌，不担心会引起代码的degree；\n\n接下来开始我们的重构：\n\n1.给每一个变量和函数重命名\n\n	重命名的方法是，让每一个变量或函数的意义明确，一目了然。\n	如果你看到一个i，不要默认它是循环变量，给它取一个有意思的名字；\n	如果你想给“对战”取一个变量名，不要这么写：dz。如果你写成fight，下一个读代码的人会对你感激不尽；\n	如果insert函数是插入成绩，那么insertScore是一个更合适的函数名称；\n	如果你的函数里，做了成绩查询和修改处理，那么用retrieveAndModifyScore来命名它；\n	做完如此之后，如果你发现乃至所有的注释都是多此一举，那么恭喜你：Well done！\n\n	然后Run -> Test，谨小慎微的确保我们的该步操作大功告成。\n\n	接下来我们深入函数的内部，厘清那些让我们力不从心的复杂逻辑。\n	\n2.改写if else逻辑\n	繁多的if else，if中的if else，else中if else，这些庞大的逻辑块看上去就让人云山雾绕，那是是时候祭出重构公式来简化它了。\n	重构的思路为：if和else的逻辑我们只能二选其一。\n	对于if，我们可在if的逻辑块里加上一个return，表明我们执行完if之后，不再涉及else的代码。\n	对于else，由于之前一部已确保if的逻辑执行后会返回，我们大可放心的将else的代码提出来，去掉else这个关键字。\n	话不多说，直接上例子：\n	if ( m_Prop.A == 1 )\n	{\n		if ( m_Prop.B == 1 )\n		{\n			return \"Good\";\n		}\n		else if ( m_Prop.B == 2 )\n		{\n			return \"Not too bad\";\n		}\n		else return \"Just so so\";\n	}\n	else if ( m_Prop.A == 2 )\n	{\n		if ( m_Prop.B == 1 )\n		{\n			if ( m_Prop.C == 1 )\n			{\n				return \"Need improvement\";\n			}\n			else return \"Need more improvement\";\n		}\n		else if ( m_Prop.B == 2 )\n		{\n			return \"Have a chance to improve\";\n		}\n		else return \"Too bad\";\n	}\n	这是一段重构前的代码，每每看到这里，都有一种给跪了的感觉。\n	于是第一步的重构开始了，我们的第一次，就从 else if ( m_Prop.A == 2 )开始，从去掉else开始。\n	这次重构后的代码如下，是一次简单的不能再简单的修改。\n	if ( m_Prop.A == 1 ){\n		if ( m_Prop.B == 1 )\n		{\n			return \"Good\";\n		}\n		else if ( m_Prop.B == 2 )\n		{\n			return \"Not too bad\";\n		}\n		else return \"Just so so\";\n	}\n\n	if ( m_Prop.A == 2 )\n	{\n		if ( m_Prop.B == 1 )\n		{\n			if ( m_Prop.C == 1 )\n			{\n				return \"Need improvement\";\n			}\n			else return \"Need more improvement\";\n		}\n		else if ( m_Prop.B == 2 )\n		{\n			return \"Have a chance to improve\";\n		}\n		else return \"Too bad\";\n	}\n	以此类推的重构后，得到如下代码：\n\n	if ( m_Prop.A == 1 ){\n		if ( m_Prop.B == 1 )\n		{\n			return \"Good\";\n		}\n\n		if ( m_Prop.B == 2 )\n		{\n			return \"Not too bad\";\n		}\n\n		 return \"Just so so\";\n	}\n\n	if ( m_Prop.A == 2 )\n	{\n		if ( m_Prop.B == 1 )\n		{\n			if ( m_Prop.C == 1 )\n			{\n				return \"Need improvement\";\n			}\n			return \"Need more improvement\";\n		}\n		if ( m_Prop.B == 2 )\n		{\n			return \"Have a chance to improve\";\n		}\n		return \"Too bad\";\n	}\n\n如果重构后的代码再也不见else，而逻辑上你很清楚与重构前相等，那么恭喜你，这一步也完成了！\n\n在每一次if else的修改后，Run -> Test，谨小慎微的确保我们的该步操作大功告成。\n\n今天探讨的是去除重复。\n\n言归正传之前，继续说说 2.改写if else逻辑。\n记得大学学谭总的C语言，教材上仿佛提到过：一个函数只能有一个出口。前面提到if之后立即return，似乎有违此理。\n好在这么写并不违背语法，于是我也可以斗胆谈谈这么做的初衷：\n\n	1.可读性\n	当函数中出现任一一个return，即意味着这个分支到此为止。这样一个个return，将一块块的逻辑分支分段。读代码的人只需专心理解每一段的逻辑，而不必耗费精力，深挖该段逻辑之后是否还有额外的处理--因为我们的代码已经return了。\n	2.避免误修改\n	诚然我们可以在每个分支的结尾，将返回值赋值给一个新的变量，在函数的末尾返回这个变量。这样做保证了函数只有一次返回，并且该处还可以做一些诸如异常捕捉的统一处理。 \n	但是，但是这就没法保证，这个作为返回值的变量，不会在后续的处理中被意外的修改。俗话说夜长梦多，个人建议还是该出手时就出手，能返回时就返回。\n\n关于这个话题，最后还是将评论里侯天资兄的评论借花献佛：\n进入enum用switch-case逻辑模块+带现实意义的常量作为case的值进行捕捉和处理，这个也会比==1， !=2, >=3这种if-else的逻辑判断的可读性好得多得多\n即使小小的if-else也需要我们足够努力，才能让读代码的人读的不费吹灰之力。\n\n写到这里，想请大家思考个问题：当我们要做什么的时候，我们会想到if-else / switch？\n是否我们是想基于不同的业务触发条件，来做不同的数据处理？亦或是判断对象的不同状态，来调用它不同的行为响应？\n好吧，我想各位已经明白我想表达的。不明白的话，可以看看多态的定义。\n有人的地方就有江湖，有分支的地方就可能改为多态。\n关于这个话题，后面有机会再行展开。\n\n当逻辑分支重构得不那么令人头疼的时候，我们来说说最令代码修改者闻风丧胆、谈之色变的问题--代码重复。\n3.去除重复代码\n过往的项目经验里，最让人头疼的便是修改重复代码，无论是因为需求变更，还是因为bug修改。当你用着关键字，一遍遍的CTRL+F，将找到之处再一遍遍的用类似的代码替换时，是否已经精疲力尽？更糟糕的是，你还会担心这样的查找，会不会有漏网之鱼。在某个可能无法用关键字找出的角落，会不会还有类似需要修改的地方，让你担惊受怕？\n遗憾的是，很多programmer意识不到这样的无用功是因为代码重复产生的。当一行行的代码用CTRL+C、CTRL+V的方式产生时，恶趣味的重复代码就注定生成了。\n将重复的代码块浓缩为函数，使用一次就调用一次这个函数，直到找不出类似代码。\n\n我相信有时候并不是程序员不知道如何解决前文提到的困扰，他们只是缺乏这么做的信心和勇气。\n想想终将修改这些重复代码时，你的疲乏和担心。反正都要一个个的修改，何不如一个个的替换为函数。用函数代替重复代码块，Run -> Test，替换一处就测试一次，直到全部的重复代码都变为函数调用。\n\n\n完成了变量、代码块的重构后，接下来谈谈如何重构一个函数。\n4.让函数只做一件事情\n我大学刚开始写C代码时，脑子里充满了如果XXX，就XXX，然后XXX的逻辑思维。\n翻译成C语言，就是main里面一大段一气呵成的代码。后来觉着这样不对啊：没用到函数啊！于是乎将相关又相邻的代码提炼出来，取一个函数名，函数调用一用上，大功告成！\n就好像下面这个修改密码的函数，咋一看逻辑清楚，似乎也没啥大问题：\n\n	public Boolean ChangePassword(int id, String oldPassword, String newPassword) {\n		oldPassword = EncodeHelper.MD5(oldPassword.trim());\n		newPassword = EncodeHelper.MD5(newPassword.trim());\n\n		if (!oldPassword.Equals(this.GetStudent(id).LoginPassword)) {\n		 return false;\n		}\n		\n		return this.UpdateStudent(new Student(id, newPassword));\n	}\n\n可是，若后续要修改密码的验证逻辑，我们还能否记得，在ChangePassword的函数里，留有一行小小的if语句必须修改？\n重构函数的方法，也是函数分割的基准：一个函数一次只能做一件事。\n而一个函数一次能做的，有且仅有下面三件事～～之一：\n\n	1.查询\n	2.修改\n	3.调用上述两个过程\n	\n按照这个思路，重构上面的代码：\n\n	public Boolean ChangePassword(int id, String oldPassword, String newPassword){\n		if(this.ValidateOldPassword(id, oldPassword)) {\n			return this.SaveNewPassword(id, newPassword);\n		}\n		return false;\n	}\n\n	private Boolean ValidateOldPassword(int id, String oldPassword){\n		oldPassword = EncodeHelper.MD5(oldPassword.trim());\n		return oldPassword.Equals(this.GetStudent(id).LoginPassword);\n	}\n\n	private Boolean SaveNewPassword(int id, String newPassword){\n		newPassword = EncodeHelper.MD5(newPassword.trim());\n		return this.UpdateStudent((new Student(id, newPassword)));\n	}\n\n完成上述重构后，每个函数体中的代码逻辑，一定是围绕着函数名所示的功能，绝无多余。\n函数一次只做一件事，至少有如下2点好处：\n\n	1.可读性强\n	我们甚至不用深入函数体，只浏览函数名就能理解其逻辑意义。\n	2.便于维护修改\n	上面的例子中，若要修改密码的验证逻辑，我们只需修改ValidateOldPassword()即可。\n\n此外，功能单一，划分维度细小的函数也有助于发现代码中的漏洞。\n例如下面的代码展示了一个游戏在服务器端，是如何返回PVP画面显示用的JSON：\n\n	//fightHistories：从PVP表中获得的记录列表\n	public String getPVPResult(int userId, int rivalId, List<FightHistoryDao> fightHistories){\n		String myProfile = getMyProfile(userId);\n		String rivalProfile = getRivalProfile(rivalId);\n		String fightHistory = getFightHistories(fightHistories);\n		return generateJsonForPVPResult(myProfile, rivalProfile, fightHistory);\n	}\n\n	private String getFightHistories(List<FightHistoryDao> fightHistoryDaos){\n		for(FightHistoryDao oneFightScore in fightHistoryDaos) {\n			//{取得对战时间}\n			//{取得转化为百分数后的分数}\n			//{取得作战详细｝\n	}\n	\n这段代码若是按照上述的方法进行重构分析，在第1和第4步是能够发现潜在的漏洞的：\n在getFightHistories()中，{取得转化为百分数后的分数}做了不止一件事：\n既将画面显示用的分数取出，做了格式转换；\n同时由于oneFightScore是List中的一个对象，因而悄无声息地修改了fightHistories中记录的值。\ngetFightHistories这个函数既查询了数据，又修改了数据。更糟糕的是，单单看这个函数名，我们很难想到它修改了fightHistories。\n若后续代码修改，调用getFightHistories之后，再次使用了已被修改过的fightHistories变量，产生不可预料的结果就不足为奇了。\n为了避免上述问题，请严格按照一次只做一事的标准分割函数，并且参数传递时尽量使用immutable变量。\n\n然后Run -> Test，保证每分割出一个函数，中间的调用和返回都准确无误。\n\n5.减少函数参数\n公用函数的参数越多，调用时了解的细节必须越多，不利于函数的公用；\n另一方面，参数越多也就意味着变数越大。当与传参有关的逻辑发生变化时，拥有多个参数的函数，总是让人顾虑重重。\n减少函数参数具体的办法有：\n\n	①函数参数 -> context变量（如cookie、session）\n	②函数参数 -> TABLE字段\n	③函数参数 -> 提取类参\n	④函数参数 -> 公共变量\n	\n这里主要讲讲③和④，\n所谓类参，就是将‘类“作为参数。比如说代码里，有多个函数都有一些固定搭配的参数，就可以将他们组合成一个类（或结构体），从而达到减少参数的目的。\n例如你在不止一个函数调用中见到过id、password这种搭配。那么就可以将他们组成一个类，取一个合适的名字，如user。\n俗话说不是一家人，不进一家门。这几个参数既然搭配出现，不如就让他们在一起吧。\n\n至于第④点：公共变量。以上面重构后的代码为例，目前重构后的代码有三个函数，分别为：\n\n	public Boolean ChangePassword(int id, String oldPassword, String newPassword)\n	private Boolean ValidateOldPassword(int id, String oldPassword)\n	private Boolean SaveNewPassword(int id, String newPassword)\n	\n这三个函数的参数虽然各有不同，但实质都是围绕三个变量来处理：\nint id, String oldPassword, String newPassword\n因此我们将这三个参数作为公共变量提取出来，改为类变量。将使用这些参数的函数作为类的方法，去掉函数参数，改为直接使用类变量。重构后的代码为：\n\n	public class Student {\n		private int id;\n		private String oldPassword;\n		private String newPassword;\n		\n		public Student(int id, String password) {\n			this.id = id;\n			this.oldPassword = password;\n			this.newPassword = password;\n		}\n		\n		public Boolean ChangePassword(){\n			if(ValidateOldPassword()) {\n				return SaveNewPassword();\n			}\n			return false;\n		}\n\n		private Boolean ValidateOldPassword(){\n			oldPassword = EncodeHelper.MD5(oldPassword.trim());\n			return oldPassword.Equals(GetStudent(id).LoginPassword);\n		}\n\n		private Boolean SaveNewPassword(){\n			newPassword = EncodeHelper.MD5(newPassword.trim());\n			return this.UpdateStudent((new Student(id, newPassword)));\n		} \n\n			//其余部分略\n	}\n\n通过提取类参、将公共变量改为类变量，使函数参数尽可能减少，越少越好。\n\n这样每重构一次函数，就修改相应的调用语句。然后Run -> Test，保证每次调用都结果不变。\n\n++++++++++++++++我是做总结的分割线++++++++++++++++\n\n到这里已经谈了关于变量、代码块、以及函数的重构方法。所有的这些重构，说到底都是为了将函数写漂亮。那什么是漂亮的函数？我的目标是：\n每个函数每次只做一件事\n将函数的处理流程和具体实现分开\n例如下面的代码，既描述了更改密码的处理流程，又描述了验证的具体实现。\n需要将处于不同的层级的两块代码分开。\n\n	public Boolean ChangePassword(int id, String oldPassword, String newPassword) {\n		oldPassword = EncodeHelper.MD5(oldPassword.trim());\n		newPassword = EncodeHelper.MD5(newPassword.trim());\n\n		if (!oldPassword.Equals(this.GetStudent(id).LoginPassword)) {\n		 return false;\n		}\n		\n		return this.UpdateStudent(new Student(id, newPassword));\n	}\n\n3. 函数读起来应该像书的目录\n我们读目录时，先看共有多少章节，再看一个章节里分了哪些小节，最后可根据索引去查询具体内容。\n于是我写的函数大体这样：\n\n	1.最高层次的函数描述处理流程，流程中的每一步就是一个函数 -> 介绍章节\n	2. 1中每一步描述处理方法，每一个方法就是一个函数 -> 章节里分小节\n	3. 2中的每一个函数描述具体算法 -> 具体内容\n	\n这样读代码时，可以先从【1流程】看起，不必纠结具体的处理方法；\n看懂后再了解【2方法】，不必拘泥于算法；\n逐层升入，以此类推...\n\n另外有一些个人的经验是：\n\n	1.不要有else；\n	2.将if、while、for里的代码块用函数代替；\n	3.尽量少的函数参数；\n	4.不要怕函数体短小（1~15行就行）；\n	\n※短小的函数读起来轻而易举，同时能将修改限定在最小范围\n\n函数的重构讲完了，来谈谈如何重构类。\n这个问题可以分解为：重组一个类和分解一个类。\n6.重组一个类\n类是怎样划分的？也许是基于你头脑中一个实体的映射，也许是基于UML的一个建模？\n但既有的代码用起来，也有这样那样的不顺手。是时候祭出法宝，重新审视既有的函数和类了。\n这个办法在重构第5法中提到过：尽可能减少函数的参数。\n\n	规则1:\n	当你发现函数的多数参数，是另一个类A的成员变量\n	－> 将该函数从现有类抽离出来，改造成为A的方法\n	规则2:\n	当你发现若干函数有相同的参数，且无有关的类变量与之对应\n	－> 重新定义一个类，将这些函数作为类方法，其相同的行参作为类的成员变量\n	重构以后发现成员方法的参数减少，成员变量在方法体内被充分使用。\n\n然后Run -> Test，确保每次函数的变化（参数变更、类间移动）都不影响其output。\n\n7.分解一个类\n在函数重构中，一直有个概念：函数一次只能做一事。\n同样的，一个类如果责任过多，做了太多太多事，也不利于代码的维护。\n如果你发现类的某些成员变量，只被部分方法所使用，而另一些变量，被其他方法所使用，就意味这你可以分解这个类。\n以一个例子来说明重构的方法：\n	public class Person {\n		private String name;\n		private String officeAreaCode;\n		private String officeNumber;\n		\n		public String getName() {\n			return name;\n		}\n		\n		public String getTelephoneNumber() {\n			return \"(\" + officeAreaCode + \")\" + officeNumber;\n		}\n		\n		public String getOfficeAreaCode() {\n			return officeAreaCode;\n		}\n		\n		public void setOfficeAreaCode(String officeAreaCode) {\n			this.officeAreaCode = officeAreaCode;\n		}\n		\n		public String getOfficeNumber() {\n			return officeNumber;\n		}\n		\n		public void setOfficeNumber(String officeNumber) {\n			this.officeNumber = officeNumber;\n		}\n	}\n	这段代码中，name只被getName()使用，其余的成员变量和方法看起来另成一派。于是我们将Person类拆分为两个：\n	public class Person {\n		private String name;\n		\n		public String getName() {\n			return name;\n		}\n		\n	}\n\n	public class TelephonePhone {\n		private String officeAreaCode;\n		private String officeNumber;\n\n		public String getTelephoneNumber() {\n			return \"(\" + officeAreaCode + \")\" + officeNumber;\n		}\n		\n		public String getOfficeAreaCode() {\n			return officeAreaCode;\n		}\n		\n		public void setOfficeAreaCode(String officeAreaCode) {\n			this.officeAreaCode = officeAreaCode;\n		}\n		\n		public String getOfficeNumber() {\n			return officeNumber;\n		}\n		\n		public void setOfficeNumber(String officeNumber) {\n			this.officeNumber = officeNumber;\n		}	\n	}\n	这样划分后两个类，责任划分清晰明了。 但人总得有个电话号码吧，所以还得把两者的联系加上：\n\n	public class Person {\n		private String name;\n		private TelephonePhone telephonePhone = new TelephonePhone();\n		\n		public String getName() {\n			return name;\n		}\n		\n		public String getTelephoneNumber() {\n			return telephonePhone.getTelephoneNumber();\n		}\n	}\n\n\n	在Person类中添加telephonePhone成员变量，建立从旧类到新类的连接关系。\n\n每次搬移一个变量或方法时，Run -> Test。\n\n\n8.消除类的重复\n经过这么多的重构尝试，你应该注意到重复是编码的大忌。\n函数中重复的代码块可变为函数，那么类中重复的变量和方法呢？Bingo，就是父类（或接口）！\n规则：\n\n	1.建立或修改父类，添加类中重复的变量和方法名；\n	2.将添加的变量或方法限定为protected或public；\n	3.之前的类继承该父类；\n	4.如果重复的方法处理逻辑一致，就在父类中实现该方法，视情况添加final限定；\n	5.如果重复的方法处理不一致，则父类中只声明方法名（或提取成接口）。视情况添加abstract限定；\n	6.移出子类中的重复变量和函数；\n	按照这种方式越重构下去，会发现父类越像是一个模版：把控了业务处理的流程，把具体的算法逻辑，交由子类重载。 －－ 这便是设计模式中的［模版模式］。\n\n子类每移出一次重复变量和函数，Run -> Test，确保子类对父类相关字段或方法的正确使用。\n\n\n个人对重构方法的理解大体就是如此了。\n在这篇文章的最后，再一次和各位分享我对重构的认识：\n\n	1.重构是个持续的过程\n	并非等到程序无法控制的最后，才进行重构。恰恰相反，从你写第一个函数、第一个类开始，就想着重构它吧。越早开始重构，就会让项目开发越早进入良性循环，避免后续莫名奇妙的错误，以及大量耗时的修改。\n	2.重构将更深入理解编程\n	审视重构后的代码，会发现在不知不觉中，用到了抽象，用到了多态，用到了设计模式。这些编程中的概念，我们往往只知道是什么，却不知道它们从何而来、为何而去？重构的过程就像一次拾遗，让代码清晰的揭示：这些概念是因何产生，以及它们被使用的场景。\n	－－人类最初数数时，只知道加法。后来它们总结出了乘法，应用在生活里简化了计算。一次次的重构，就是不断总结、孰能生巧的过程。我们回顾重构后的代码，给它分类，叫它XX模式。时间久了，编程遇到类似的需求时，就会自然而然想使用该模式。\n\n在过去的项目中，见识过糟糕的代码是如何带来灾难性的后果的：要不就是程序产生莫名奇妙的错误，要不就是一次小小的修改就牵一发动全身；\n而另一方面，我们也曾体会过重构带来的美妙：一切都是简洁易修改的。往往我们面对一次大的逻辑变动，经调查后才发现，原来只需改一个函数，一切都会迎刃而解。\nWow，重构让一切的代码，都变得刚刚好！\n\n前前前回书有说到，有if、else的地方就有可能使用多态。举一个例子，JAVA的对象在未创建时为NULL，对一个NULL对象操作会引发系统错误。因而在代码中常需要对一个对象是否为NULL进行判断，如：\npublic Book getBook(int id) {\n	if (id < 0) {\n		return null;\n	}\n	return new Book(1, \"Design Pattern\", 100);\n}\nBook book = getBook(-1);\nif (book != null) {\n   book.getName();			\n}\n\nbook != null 和 book == null成了两个分支。我们可以：\n\n	1.添加Book的一个NULL子类\n	2.在创建Book对象时，视情况创建NULL子类\n	3.在调用Book方法的逻辑处利用多态，去掉对象是否为null的判断\n\n重构后的代码变为：\n\n		//添加的Null对象\n		public Class NullBook extends Book {\n				public NullBook() {\n				}\n\n			@Override\n			public String getName() {\n				return \"\";\n			}\n		}\n		//创建Book对象\n		public Book getBook(int id) {\n			if (id < 0) {\n				return new NullBook();\n			}\n			return new Book(1, \"Design Pattern\", 100);\n		}\n		//调用Book方法时去掉null判断\n		Book book = getBook(-1);  \n		book.getName();',1471485234.81964),('001471487005747dbeb1b1cc03e4fe78e2790d5f77273ab000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','Python生成器generator之next和send运行流程','Python生成器generator之next和send运行流程','对于普通的生成器，第一个next调用，相当于启动生成器，会从生成器函数的第一行代码开始执行，直到第一次执行完yield语句（第4行）后，跳出生成器函数。\n然后第二个next调用，进入生成器函数后，从yield语句的下一句语句（第5行）开始执行，然后重新运行到yield语句，执行后，跳出生成器函数，\n后面再次调用next，依次类推。下面是一个列子：\n\n		 def consumer():\n		     r = \'here\'\n		     for i in xrange(3):\n		         yield r\n		         r = \'200 OK\'+ str(i)\n		 c = consumer()\n		 n1 = c.next()\n		 n2 = c.next()\n		 n3 = c.next()\n\n了解了next()如何让包含yield的函数执行后，我们再来看另外一个非常重要的函数send(msg)。其实next()和send()在一定意义上作用是相似的，区别是send()可以传递yield表达式的值进去，而next()不能传递特定的值，只能传递None进去。因此，我们可以看做c.next() 和 c.send(None) 作用是一样的。\n需要提醒的是，第一次调用时，请使用next()语句或是send(None)，不能使用send发送一个非None的值，否则会出错的，因为没有Python yield语句来接收这个值。\n下面来着重说明下send执行的顺序。当第一次send（None）（对应11行）时，启动生成器，从生成器函数的第一行代码开始执行，直到第一次执行完yield（对应第4行）后，跳出生成器函数。这个过程中，n1一直没有定义。\n下面运行到send（1）时，进入生成器函数，注意这里与调用next的不同。这里是从第4行开始执行，把1赋值给n1，但是并不执行yield部分。下面继续从yield的下一语句继续执行，然后重新运行到yield语句，执行后，跳出生成器函数。\n即send和next相比，只是开始多了一次赋值的动作，其他运行流程是相同的。\n\n	 def consumer():\n		 r = \'here\'\n		 while True:\n			 n1 = yield r\n			 if not n1:\n				 return\n			 print(\'[CONSUMER] Consuming %s...\' % n1)\n			 r = \'200 OK\'+str(n1)\n\n	 def produce(c):\n		 aa = c.send(None)\n		 n = 0\n		 while n < 5:\n			 n = n + 1\n			 print(\'[PRODUCER] Producing %s...\' % n)\n			 r1 = c.send(n)\n			 print(\'[PRODUCER] Consumer return: %s\' % r1)\n		 c.close()\n\n	 c = consumer()\n	 produce(c)\n\n运行结果：\n\n	[PRODUCER] Producing 1...\n	[CONSUMER] Consuming 1...\n	[PRODUCER] Consumer return: 200 OK1\n	[PRODUCER] Producing 2...\n	[CONSUMER] Consuming 2...\n	[PRODUCER] Consumer return: 200 OK2\n	[PRODUCER] Producing 3...\n	[CONSUMER] Consuming 3...\n	[PRODUCER] Consumer return: 200 OK3\n	[PRODUCER] Producing 4...\n	[CONSUMER] Consuming 4...\n	[PRODUCER] Consumer return: 200 OK4\n	[PRODUCER] Producing 5...\n	[CONSUMER] Consuming 5...\n	[PRODUCER] Consumer return: 200 OK5',1471487005.74765),('001471707261015c5ce42ae749a42fb8307fa3c37c67429000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','3Sum','Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.','Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n\n   Note: The solution set must not contain duplicate triplets.\n   \n	   For example, given array S = [-1, 0, 1, 2, -1, -4],\n\n		A solution set is:\n		[\n		  [-1, 0, 1],\n		  [-1, -1, 2]\n		]\n\n解题思路：\n  暴力求解的思路自然是三重循环，而且需要判断重复的情况。此处，可以先固定一个值，然后对于剩下的与2SUM问题相似，注意重复情况如何排除。以下是解题代码：\n  \n	  vector<vector<int>> threeSum(vector<int>& nums) {\n			vector<vector<int>> result;\n			if(nums.size()<3)\n			  return result;\n			int first = 0;\n			sort(nums.begin(),nums.end());\n			\n			\n			for(int i = 0;i<nums.size() - 2;i++){\n			   first = nums[i];\n			   int left = i+1;\n			   int right = nums.size() - 1;\n			   while(right>left){\n				   int temp = first+nums[left]+nums[right];\n				   if(temp>0)\n					  right--;\n				   if(temp<0)\n					  left++;\n				   if(temp==0){\n					   vector<int> temp_1;\n					   temp_1.push_back(first);\n					   temp_1.push_back(nums[left]);\n					   temp_1.push_back(nums[right]);\n					   while(left<right&&nums[left]==nums[left+1])\n						 left++;\n					   left++;\n					   while(right>left&&nums[right]==nums[right-1])\n						 right--;\n					   right--;\n					   result.push_back(temp_1);\n				   }\n			   }\n			   while(i<nums.size()&&nums[i]==nums[i+1])\n				 i++;\n			}\n			\n			return result;\n			\n		}\n\n\n另有一题Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n\n    \n    For example, given array S = {-1 2 1 -4}, and target = 1.\n    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n	\n	该题解决思路也可以参照本题',1471707261.01574),('001471765630709e41d7e2753684538b7aab6d81952ca9f000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','remove the nth node from the end of list','Given a linked list, remove the nth node from the end of list and return its head.\n\nFor example,\n\n   Given linked list: 1->2->3->4->5, and n = 2.','Given a linked list, remove the nth node from the end of list and return its head.\n\nFor example,\n\n   Given linked list: 1->2->3->4->5, and n = 2.\n\n   After removing the second node from the end, the linked list becomes 1->2->3->5.\nNote:\nGiven n will always be valid.\nTry to do this in one pass.\n\nSubscribe to see which companies asked this question\n\n\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        //维护一个N的队列，每次存入当前的后N个元素\n        ListNode* temp_head = head;\n        ListNode* temp[n+1];// = new ListNode[n];\n        memset(temp,0,sizeof(int)*n);\n        int i = 0;\n        while(head){\n            temp[(i++)%(n+1)] = head;\n            head = head->next;\n        }\n        ListNode* pre;\n        ListNode* remove;\n        if(i==1)\n          return NULL;\n        if(n==i){\n            return temp_head->next;\n        }else{\n           pre = temp[i%(n+1)];\n           remove = temp[(i+1)%(n+1)];\n        }\n        pre->next = remove->next;\n        return temp_head;\n    }',1471765630.70948),('0014717934911656a1f35cede4e4714af3eec632abc49b2000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','Generate Parentheses','Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.','Generate Parentheses\n\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\nFor example, given n = 3, a solution set is:\n\n	[\n	  \"((()))\",\n	  \"(()())\",\n	  \"(())()\",\n	  \"()(())\",\n	  \"()()()\"\n	]\n	\n针对一个长度为2n的合法排列，第1到2n个位置都满足如下规则：左括号的个数大于等于右括号的个数。所以，我们就可以按照这个规则去打印括号\n：假设在位置k我们还剩余left个左括号和right个右括号，如果left>0，则我们可以直接打印左括号，而不违背规则。能否打印右括号，我们还必\n须验证left和right的值是否满足规则，如果left>=right，则我们不能打印右括号，因为打印会违背合法排列的规则，否则可以打印右括号。如果\nleft和right均为零，则说明我们已经完成一个合法排列，可以将其打印出来。通过深搜，我们可以很快地解决问题。\n\n    void generate(int left,int right,vector<string> &s,string ss){\n    	if(left==0&&right==0){\n    		s.push_back(ss);\n    		return ;\n    	}\n    	if(left>0)\n    	   generate(left-1,right,s,ss+\'(\');\n    	if(right>0&&left<right)\n    	   generate(left,right-1,s,ss+\')\');\n	}\n\n    vector<string> generateParenthesis(int n) {\n         vector<string> tt;\n         generate(n,n,tt,\"\");\n    	 return tt;\n    }',1471793491.16586),('0014718719463474ab89bd09d854f4aa5b261315f711ca4000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','VIM（一）','学习VIM编辑器一','VIM(一)\n\n一.基本用法\n	启动Vim后，vim在 Normal 模式下。让我们进入 Insert 模式，请按下键i(还有别的如a等)\n	如果你想返回 Normal 模式，请按 ESC 键。\n  \n		i → 当前光标前面插入\n		a → 当前光标后面插入\n		I → 当前行前面插入\n		A → 当前光标后面插入\n		o → 当前行前面插入一行\n		O → 当前行后面插入一行\n		x → 删当前光标所在的一个字符\n		X → 删当前光标所在前一个字符\n		:wq → 存盘 + 退出 (:w 存盘, :q 退出)\n        u → 撤销操作	\n        y → 复制字符\n        yy/Y → 复制一行 		\n		dd → 删除当前行，并把删除的行存到剪贴板里\n		p → 粘贴剪贴板\n		hjkl →你也可以使用光标键 (←↓↑→)\n		:help <command> → 显示相关命令的帮助。\n\n二.进阶用法\n\n简单的移动光标:\n   \n    0 → 数字零，到行头\n	^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）\n	$ → 到本行行尾\n	g_ → 到本行最后一个不是blank字符的位置。\n	/pattern → 搜索 pattern 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个）\n	\n拷贝/粘贴:\n	\n	P → 粘贴\n    yy → 拷贝当前行于当前行 ddP\n	\nUndo/Redo：\n	\n	u → undo\n    <C-r> → redo\n	\n打开/保存/退出/改变文件(Buffer)：\n\n	:e <path/to/file> → 打开一个文件\n	:w → 存盘\n	:saveas <path/to/file> → 另存为 <path/to/file>\n	:x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车)\n	:q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。\n	:bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。',1471871946.34738),('001471872845964e8f303b75c0649e4a9c5f7f66d727637000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','VIM(二)','VIM进阶学习','1.vim是怎么重复命令\n\n	. → (小数点) 可以重复上一次的命令\n	N<command> → 重复某个命令N次\n	2dd → 删除2行\n	3p → 粘贴文本3次\n	5idesu [ESC] → 会写下 “desu desu desu desu desu “\n	3. → 重复 3 次 “desu” (注意：不是 15).\n\n2.光标移动更有效率\n\n	NG → 到第 N 行 （陈皓注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）\n	gg → 到第一行。（陈皓注：相当于1G，或 :1）\n	G → 到最后一行。\n	按单词移动：\n	  w → 到下一个单词的开头。\n      e → 到下一个单词的结尾。\n	  如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成\n	  如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（陈皓注：程序语句）\n\n更牛逼的：\n	\n	% : 匹配括号移动，包括 (, {, [. （陈皓注：你需要把光标先移到括号上）\n    * 和 #:  匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）\n\n3.很多命令还可以如下来干：\n\n	<start position><command><end position>\n\n	例如 0y$ 命令意味着：\n	0 → 先到行头\n	y → 从这里开始拷贝\n	$ → 拷贝到本行最后一个字符\n	可以输入 ye，从当前位置拷贝到本单词的最后一个字符。\n	也可以输入 y2/foo 来拷贝2个 “foo” 之间的字符串。\n\n	还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：\n	d (删除 )\n	v (可视化的选择) 可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，\n	                 你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等\n	gU (变大写)\n	gu (变小写)\n	等等',1471872845.96471),('0014718749024075b62d70a31894a2895dbfc88c5033ef6000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','VIM(三)','Vim的超能力，杀手级功能','VIM杀手级的功能，下面这些功能是只用vim的原因。\n\n1.在当前行上移动光标: 0 ^ $ f F t T , ;\n\n		0 → 到行头\n		^ → 到本行的第一个非blank字符\n		$ → 到行尾\n		g_ → 到本行最后一个不是blank字符的位置。\n		fa → 到下一个为a的字符处，你也可以fs到下一个为s的字符。\n		t, → 到逗号前的第一个字符。逗号可以变成其它字符。\n		3fa → 在当前行查找第三个出现的a。\n		F 和 T → 和 f 和 t 一样，只不过是相反方向。\n		Line moves\n		还有一个很有用的命令是 dt\" → 删除所有的内容，直到遇到双引号—— \"。\n\n2.区域选择 <action>a<object> 或 <action>i<object>\n\n		在visual 模式下，这些命令很强大，其命令格式为\n		<action>a<object> 和 <action>i<object>\n\n		action可以是任何的命令，如 d (删除), y (拷贝), v (可以视模式选择)。\n		object 可能是： w 一个单词， W 一个以空格为分隔的单词， s 一个句字， p 一个段落。也可以是一个特别的字符：\"、 \'、 )、 }、 ]。\n		假设你有一个字符串 (map (+) (\"foo\")).而光标键在第一个 o 的位置。\n\n		vi\" → 会选择 foo.\n		va\" → 会选择 \"foo\".\n		vi) → 会选择 \"foo\".\n		va) → 会选择(\"foo\").\n		v2i) → 会选择 map (+) (\"foo\")\n		v2a) → 会选择 (map (+) (\"foo\"))\n\n3.块操作: <C-v>\n\n	块操作，典型的操作： 0 <C-v> <C-d> I-- [ESC]\n	^ → 到行头\n	<C-v> → 开始块操作\n	<C-d> → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的)\n	I-- [ESC] → I是插入，插入“--”，按ESC键来为每一行生效。\n	Rectangular blocks\n\n4.自动提示： <C-n> 和 <C-p>\n\n		在 Insert 模式下，你可以输入一个词的开头，然后按 <C-p>或是<C-n>，自动补齐功能就出现了\n		Completion\n\n\n5.分屏: :split 和 vsplit.\n\n	:split → 创建分屏 (:vsplit创建垂直分屏)\n	<C-w><dir> : dir就是方向，可以是 hjkl 或是 ←↓↑→ 中的一个，其用来切换分屏。\n	<C-w>_ (或 <C-w>|) : 最大化尺寸 (<C-w>| 垂直分屏)\n	<C-w>+ (或 <C-w>-) : 增加尺寸\n	\n6.可视化选择： v,V,<C-v>\n  前面，我们看到了 <C-v>的示例 我们可以使用 v 和 V。一但被选好了，你可以做下面的事：\n\n	J → 把所有的行连接起来（变成一行）\n	< 或 > → 左右缩进\n	= → 自动给缩进 （这个功能相当强大，我太喜欢了）\n\n在所有被选择的行后加上点东西：\n\n	<C-v>\n	选中相关的行 (可使用 j 或 <C-d> 或是 /pattern 或是 % 等……)\n	$ 到行最后\n	A, 输入字符串，按 ESC。\n\n结束语：\n\n		上面是我最常用的90%的命令。\n		在两到三周后，你会感到vim的强大的。\n		运行vimtutor直到你熟悉了那些基本命令。\n		学习vim就像学弹钢琴一样，一旦学会，受益无穷。',1471874902.40708);
/*!40000 ALTER TABLE `blogs` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `comments`
--

DROP TABLE IF EXISTS `comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `comments` (
  `id` varchar(50) NOT NULL,
  `blog_id` varchar(50) NOT NULL,
  `user_id` varchar(50) NOT NULL,
  `user_name` varchar(50) NOT NULL,
  `user_image` varchar(500) NOT NULL,
  `content` mediumtext NOT NULL,
  `created_at` double NOT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_created_at` (`created_at`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `comments`
--

LOCK TABLES `comments` WRITE;
/*!40000 ALTER TABLE `comments` DISABLE KEYS */;
INSERT INTO `comments` VALUES ('0014713318586503d4fd546828743d3bd351152ddd6531f000','001471049765163e135d7630f774dfe99c6a30612f5f36e000','001471015498178ad49a237334f4feab9690c76d564abf3000','朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120','自己评论下吧',1471331858.65073);
/*!40000 ALTER TABLE `comments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `users`
--

DROP TABLE IF EXISTS `users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `users` (
  `id` varchar(50) NOT NULL,
  `email` varchar(50) NOT NULL,
  `passwd` varchar(50) NOT NULL,
  `admin` tinyint(1) NOT NULL,
  `name` varchar(50) NOT NULL,
  `image` varchar(500) NOT NULL,
  `created_at` double NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_email` (`email`),
  KEY `idx_created_at` (`created_at`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users`
--

LOCK TABLES `users` WRITE;
/*!40000 ALTER TABLE `users` DISABLE KEYS */;
INSERT INTO `users` VALUES ('001471015498178ad49a237334f4feab9690c76d564abf3000','1677886138@qq.com','70137830d6210cfb070854efd06ac1866f2c12d6',1,'朱金海','http://www.gravatar.com/avatar/b124f834fa895e65f3703c25eafe530a?d=mm&s=120',1471015498.17826),('00147141849384136105b102d634c029e313bbdd82a55ee000','1076334016@qq.com','47ccbe8afe5f8db17a054a955a36bc4733d0cb0e',0,'小学生','http://www.gravatar.com/avatar/fbbabb1ace92893179cfcfa0a843c5ab?d=mm&s=120',1471418493.84189);
/*!40000 ALTER TABLE `users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2016-08-23 16:03:43
